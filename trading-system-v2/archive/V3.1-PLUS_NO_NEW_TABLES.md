# V3.1-Plus 优化方案 - 无新表设计

**设计原则**: 复用现有表结构，避免冗余  
**分析时间**: 2025-10-12  

---

## 📊 现有表结构分析

### 1. simulation_trades（核心交易表）
**已有字段**（V3.1相关）:
- `early_trend_detected` ✅
- `fake_breakout_filter_passed` ✅
- `confidence_level` ✅
- `initial_atr_multiplier` ✅
- `current_atr_multiplier` ✅
- `stop_loss_type` ✅
- `trailing_activated` ✅
- `entry_time`, `exit_time`, `pnl`, `status` ✅

**结论**: 这个表已经有V3.1的所有核心字段，只需要添加少量V3.1-Plus字段即可！

### 2. strategy_execution_logs（信号日志表）
**用途**: 记录每次策略执行的详细日志  
**可用于**: 存储入场确认详情、Pullback检测结果  
**结论**: 可复用，不需要新建v3_1_signal_logs

### 3. strategy_params（参数表）
**用途**: 存储策略参数配置  
**可用于**: 存储V3.1-Plus所有参数  
**结论**: 可复用

### 4. strategy_performance_summary（性能统计表）
**用途**: 存储策略性能汇总  
**可用于**: 胜率跟踪、性能监控  
**结论**: 可复用

---

## 🎯 V3.1-Plus 需求映射

### 需求1: 交易冷却管理
**原设计**: 新建v3_trade_cooldown表  
**优化方案**: 
- ✅ 使用**内存缓存**（Map对象）存储冷却状态
- ✅ 查询simulation_trades的最后entry_time
- ✅ 重启后从数据库恢复状态

**优势**:
- 无需新表
- 查询更快（内存）
- 减少数据库写入

### 需求2: 交易历史（胜率跟踪）
**原设计**: 新建v3_trade_history表  
**优化方案**:
- ✅ 直接查询simulation_trades表
- ✅ 按symbol + strategy_name + status='CLOSED'筛选
- ✅ 计算最近N笔的胜率

**SQL示例**:
```sql
SELECT 
    COUNT(*) as total,
    SUM(CASE WHEN pnl > 0 THEN 1 ELSE 0 END) as wins
FROM (
    SELECT pnl
    FROM simulation_trades
    WHERE symbol_id = ? 
      AND strategy_name = 'V3'
      AND status = 'CLOSED'
    ORDER BY exit_time DESC
    LIMIT 12
) recent;
```

**优势**:
- 无需新表
- 无需数据同步
- 数据一致性100%

### 需求3: 分批建仓订单
**原设计**: 新建v3_staged_orders表  
**优化方案**:
- ✅ 在simulation_trades添加JSON字段 `staged_orders`
- ✅ 存储分批详情：`{stage1: {size, price, time}, stage2: {...}}`
- ✅ 添加字段 `staged_entry`, `stage_count`

**JSON示例**:
```json
{
  "stages": [
    {"stage": 1, "size": 0.5, "price": 62000, "time": "2025-10-12T10:00:00Z", "status": "FILLED"},
    {"stage": 2, "size": 0.5, "price": 62100, "time": "2025-10-12T10:15:00Z", "status": "FILLED"}
  ],
  "breakeven_moved": true,
  "breakeven_price": 62050
}
```

**优势**:
- 无需新表
- 避免一对多关系复杂性
- 查询更简单

### 需求4: 入场确认详情
**原设计**: 存储在新表  
**优化方案**:
- ✅ 在simulation_trades添加JSON字段 `entry_confirmation`
- ✅ 存储：`{volOk, deltaOk, earlyOk, smartOk, confirmCount, entryMode}`

**JSON示例**:
```json
{
  "volOk": true,
  "deltaOk": true,
  "earlyOk": true,
  "smartOk": false,
  "confirmCount": 3,
  "entryMode": "breakout",
  "pullbackDetected": false,
  "smartMoneyScore": 0.45
}
```

---

## 📝 最终数据库修改方案

### 仅需扩展simulation_trades表

```sql
-- V3.1-Plus 扩展字段（最小化修改）
ALTER TABLE simulation_trades
ADD COLUMN entry_mode VARCHAR(20) DEFAULT NULL COMMENT '入场模式: breakout/pullback/momentum',
ADD COLUMN entry_confirmation JSON DEFAULT NULL COMMENT '入场确认详情',
ADD COLUMN staged_entry BOOLEAN DEFAULT FALSE COMMENT '是否分批入场',
ADD COLUMN staged_orders JSON DEFAULT NULL COMMENT '分批订单详情',
ADD COLUMN recent_winrate DECIMAL(5,2) DEFAULT NULL COMMENT '入场时最近胜率',
ADD COLUMN winrate_throttle_active BOOLEAN DEFAULT FALSE COMMENT '胜率保护是否激活',
ADD COLUMN cooldown_bypassed BOOLEAN DEFAULT FALSE COMMENT '是否绕过冷却（强制入场）';
```

### 参数配置（复用strategy_params）

```sql
-- 方案1: 使用现有param_name格式
INSERT INTO strategy_params (param_name, param_value, param_type, category, description) VALUES
-- V3.1-Plus参数（category固定为'V3'）
('v3_confirmation_wait', '1', 'number', 'V3', '突破确认等待(15M根数)'),
('v3_vol_factor', '1.2', 'number', 'V3', '成交量确认倍数'),
('v3_delta_threshold', '0.04', 'number', 'V3', 'Delta阈值'),
('v3_pullback_first_leg_ratio', '0.5', 'number', 'V3', 'Pullback首仓比例'),
('v3_k_entry_high', '1.4', 'number', 'V3', 'High置信度止损ATR倍数'),
('v3_k_entry_med', '2.0', 'number', 'V3', 'Med置信度止损ATR倍数'),
('v3_k_entry_low', '3.0', 'number', 'V3', 'Low置信度止损ATR倍数'),
('v3_breakout_multiplier', '1.25', 'number', 'V3', '突破模式止损倍数'),
('v3_pullback_multiplier', '0.9', 'number', 'V3', '回撤模式止损倍数'),
('v3_trail_step', '0.4', 'number', 'V3', '追踪止盈步长(ATR倍数)'),
('v3_tp_factor', '2.0', 'number', 'V3', '止盈倍数因子'),
('v3_cooldown_minutes', '45', 'number', 'V3', '冷却时间(分钟)'),
('v3_max_daily_trades', '6', 'number', 'V3', '每日最大交易次数'),
('v3_recent_window', '12', 'number', 'V3', '胜率跟踪窗口(笔数)'),
('v3_winrate_threshold', '0.30', 'number', 'V3', '胜率保护阈值'),
('v3_time_stop_base', '60', 'number', 'V3', '时间止损基准(分钟)')
ON DUPLICATE KEY UPDATE param_value = VALUES(param_value);
```

---

## 💾 内存缓存设计

### CooldownCache类

```javascript
class CooldownCache {
  constructor() {
    this.cache = new Map(); // symbol -> {lastEntry, dailyCount, lastResetDate}
  }
  
  // 从数据库恢复状态
  async restore(database) {
    const result = await database.pool.query(`
      SELECT symbol_id, MAX(entry_time) as last_entry, 
             COUNT(*) as daily_count
      FROM simulation_trades
      WHERE strategy_name = 'V3'
        AND DATE(entry_time) = CURDATE()
      GROUP BY symbol_id
    `);
    
    for (const row of result[0]) {
      this.cache.set(row.symbol_id, {
        lastEntry: new Date(row.last_entry).getTime(),
        dailyCount: row.daily_count,
        lastResetDate: new Date().toDateString()
      });
    }
  }
  
  // 检查是否可以入场
  canEnter(symbol, cooldownMinutes, maxDaily) {
    const info = this.cache.get(symbol);
    if (!info) return {allowed: true, reason: 'first_entry'};
    
    // 检查日期重置
    const today = new Date().toDateString();
    if (info.lastResetDate !== today) {
      info.dailyCount = 0;
      info.lastResetDate = today;
    }
    
    // 检查冷却时间
    const minutesSince = (Date.now() - info.lastEntry) / 1000 / 60;
    if (minutesSince < cooldownMinutes) {
      return {allowed: false, reason: 'cooldown_active', minutesRemaining: cooldownMinutes - minutesSince};
    }
    
    // 检查每日限制
    if (info.dailyCount >= maxDaily) {
      return {allowed: false, reason: 'daily_limit_reached', dailyCount: info.dailyCount};
    }
    
    return {allowed: true, reason: 'ok'};
  }
  
  // 更新入场记录
  updateEntry(symbol) {
    const info = this.cache.get(symbol) || {dailyCount: 0, lastResetDate: new Date().toDateString()};
    const today = new Date().toDateString();
    
    if (info.lastResetDate !== today) {
      info.dailyCount = 1;
      info.lastResetDate = today;
    } else {
      info.dailyCount++;
    }
    
    info.lastEntry = Date.now();
    this.cache.set(symbol, info);
  }
}
```

---

## 📊 数据查询封装

### WinRateTracker类

```javascript
class WinRateTracker {
  constructor(database) {
    this.database = database;
  }
  
  async getRecentWinRate(symbolId, window = 12) {
    const [rows] = await this.database.pool.query(`
      SELECT 
        COUNT(*) as total,
        SUM(CASE WHEN pnl > 0 THEN 1 ELSE 0 END) as wins,
        AVG(pnl) as avg_pnl
      FROM (
        SELECT pnl
        FROM simulation_trades
        WHERE symbol_id = ?
          AND strategy_name = 'V3'
          AND status = 'CLOSED'
        ORDER BY exit_time DESC
        LIMIT ?
      ) recent
    `, [symbolId, window]);
    
    const row = rows[0];
    return {
      total: row.total,
      wins: row.wins,
      winRate: row.total > 0 ? (row.wins / row.total) : null,
      avgPnl: row.avg_pnl
    };
  }
  
  async shouldThrottle(symbolId, threshold = 0.30, window = 12) {
    const stats = await this.getRecentWinRate(symbolId, window);
    if (stats.total < window) return {throttle: false, reason: 'insufficient_data'};
    if (stats.winRate < threshold) {
      return {
        throttle: true,
        reason: 'low_winrate',
        winRate: stats.winRate,
        adjustments: {
          scoreBonus: -10,
          sizeMultiplier: 0.5
        }
      };
    }
    return {throttle: false, reason: 'ok', winRate: stats.winRate};
  }
}
```

---

## ✅ 优势总结

### 对比原方案

| 项目 | 原方案（新建3表） | 优化方案（无新表） | 优势 |
|------|------------------|-------------------|------|
| **表数量** | +3个新表 | 0个新表 | 简化维护 |
| **字段数量** | simulation_trades +8 | simulation_trades +7 | 几乎相同 |
| **查询复杂度** | JOIN查询 | 单表查询 | 更快 |
| **数据一致性** | 需要同步 | 天然一致 | 更可靠 |
| **存储空间** | 多表索引 | 少量JSON | 更节省 |
| **开发复杂度** | 高（多表关系） | 低（单表+缓存） | 更简单 |
| **性能** | JOIN开销 | 缓存+单表 | 更优 |

### 关键优势

1. **✅ 零冗余**: 完全复用现有表结构
2. **✅ 高性能**: 内存缓存 + 单表查询
3. **✅ 易维护**: 无需管理多表关系
4. **✅ 数据一致**: 单一数据源
5. **✅ 向后兼容**: 不影响现有功能
6. **✅ 快速部署**: 仅需ALTER一张表

---

## 📋 实施检查清单

### Phase 1: 数据库扩展（5分钟）
- [ ] 执行ALTER TABLE添加7个字段
- [ ] 插入V3.1-Plus参数到strategy_params
- [ ] 验证字段添加成功

### Phase 2: 代码实现（2小时）
- [ ] 实现CooldownCache类
- [ ] 实现WinRateTracker类  
- [ ] 实现EntryConfirmationManager
- [ ] 实现PullbackDetector
- [ ] 实现StagedEntryManager
- [ ] 实现DynamicStopLossPlus

### Phase 3: 集成测试（30分钟）
- [ ] 单元测试各模块
- [ ] 集成测试完整流程
- [ ] 性能测试

### Phase 4: VPS部署（20分钟）
- [ ] 执行数据库迁移
- [ ] 部署代码
- [ ] 验证功能
- [ ] 监控性能

---

## 🎯 下一步行动

1. ✅ 创建最小化ALTER TABLE脚本
2. ⏳ 实现核心模块（CooldownCache, WinRateTracker）
3. ⏳ 集成到V3策略
4. ⏳ 测试和部署

**总工期**: 约3小时（减少50%）  
**风险等级**: 低（无新表，改动最小）  
**回滚方案**: 简单（删除新增字段即可）

---

**设计优势**: 🏆 最小化改动，最大化复用，零冗余！

