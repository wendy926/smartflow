# é€šç”¨äº¤æ˜“ç³»ç»Ÿæ¶æ„è®¾è®¡æ–¹æ¡ˆ

**æ—¥æœŸ**: 2025-07-07  
**ç‰ˆæœ¬**: v3.0.0  
**è®¾è®¡èŒƒå›´**: å¤šå¸‚åœºäº¤æ˜“ç³»ç»Ÿ + AIæ¨¡å—è§£è€¦ + è·¨æœºæˆ¿éƒ¨ç½²

---

## ğŸ“‹ ç³»ç»Ÿæ¶æ„æ¦‚è§ˆ

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å‰ç«¯å±‚ (Web UI)                          â”‚
â”‚                    React/Vue + WebSocket                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      APIç½‘å…³å±‚ (API Gateway)                    â”‚
â”‚              Nginx + Load Balancer + Rate Limiting             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      å¾®æœåŠ¡å±‚ (Microservices)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  äº¤æ˜“æœåŠ¡   â”‚  â”‚  AIæœåŠ¡     â”‚  â”‚  æ•°æ®æœåŠ¡   â”‚  â”‚  é€šçŸ¥æœåŠ¡   â”‚ â”‚
â”‚  â”‚ Trading     â”‚  â”‚ AI Agent    â”‚  â”‚ Data        â”‚  â”‚ Notificationâ”‚ â”‚
â”‚  â”‚ Service     â”‚  â”‚ Service     â”‚  â”‚ Service     â”‚  â”‚ Service     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æ ¸å¿ƒå¼•æ“å±‚ (Core Engines)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  ç­–ç•¥å¼•æ“   â”‚  â”‚  é£é™©ç®¡ç†   â”‚  â”‚  å›æµ‹å¼•æ“   â”‚  â”‚  è®¢å•ç®¡ç†   â”‚ â”‚
â”‚  â”‚ Strategy    â”‚  â”‚ Risk        â”‚  â”‚ Backtest    â”‚  â”‚ Order       â”‚ â”‚
â”‚  â”‚ Engine      â”‚  â”‚ Manager      â”‚  â”‚ Engine      â”‚  â”‚ Manager     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      é€‚é…å™¨å±‚ (Adapters)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Binance     â”‚  â”‚ Aè‚¡é€‚é…å™¨   â”‚  â”‚ ç¾è‚¡é€‚é…å™¨   â”‚  â”‚ æ•°æ®é€‚é…å™¨   â”‚ â”‚
â”‚  â”‚ Adapter     â”‚  â”‚ CN Stock    â”‚  â”‚ US Stock    â”‚  â”‚ Data        â”‚ â”‚
â”‚  â”‚             â”‚  â”‚ Adapter     â”‚  â”‚ Adapter     â”‚  â”‚ Adapter     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æ•°æ®å±‚ (Data Layer)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ MySQL        â”‚  â”‚ Redis       â”‚  â”‚ InfluxDB     â”‚  â”‚ MongoDB      â”‚ â”‚
â”‚  â”‚ (äº¤æ˜“æ•°æ®)   â”‚  â”‚ (ç¼“å­˜)      â”‚  â”‚ (æ—¶åºæ•°æ®)   â”‚  â”‚ (æ—¥å¿—æ•°æ®)   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—ï¸ æ ¸å¿ƒæ¶æ„è®¾è®¡

### 1. é€šç”¨äº¤æ˜“ç³»ç»Ÿæ ¸å¿ƒ

#### 1.1 å¸‚åœºæŠ½è±¡æ¥å£

```typescript
// src/core/interfaces/IMarket.ts
interface IMarket {
  readonly marketType: MarketType;
  readonly tradingHours: TradingHours;
  readonly symbols: string[];
  readonly timezone: string;
}

interface IExchangeAdapter {
  readonly market: IMarket;
  
  // åŸºç¡€æ•°æ®æ¥å£
  getKlines(symbol: string, timeframe: Timeframe, limit?: number): Promise<Kline[]>;
  getTicker(symbol: string): Promise<Ticker>;
  getOrderBook(symbol: string): Promise<OrderBook>;
  
  // äº¤æ˜“æ¥å£
  placeOrder(order: OrderRequest): Promise<OrderResponse>;
  cancelOrder(orderId: string): Promise<boolean>;
  getOrders(symbol?: string): Promise<Order[]>;
  
  // è´¦æˆ·æ¥å£
  getAccount(): Promise<Account>;
  getPositions(symbol?: string): Promise<Position[]>;
  
  // å¸‚åœºç‰¹å®šæ•°æ®
  getMarketMetrics(symbol: string): Promise<MarketMetrics>;
}

enum MarketType {
  CRYPTO = 'crypto',
  CN_STOCK = 'cn_stock', 
  US_STOCK = 'us_stock'
}

interface TradingHours {
  timezone: string;
  sessions: TradingSession[];
}

interface TradingSession {
  open: string;  // "09:30"
  close: string; // "15:00"
  days: number[]; // [1,2,3,4,5] å‘¨ä¸€åˆ°å‘¨äº”
}
```

#### 1.2 ç»Ÿä¸€æ•°æ®æ¨¡å‹

```typescript
// src/core/models/MarketData.ts
interface Kline {
  timestamp: Date;
  open: number;
  high: number;
  low: number;
  close: number;
  volume: number;
  symbol: string;
  timeframe: Timeframe;
  marketType: MarketType;
}

interface MarketMetrics {
  // é€šç”¨æŒ‡æ ‡
  volume: number;
  turnover?: number;
  
  // åŠ å¯†è´§å¸ç‰¹æœ‰
  fundingRate?: number;
  openInterest?: number;
  delta?: number;
  liquidation?: LiquidationData;
  
  // Aè‚¡ç‰¹æœ‰
  financingBalance?: number;
  northwardFunds?: number;
  volumeRatio?: number;
  peRatio?: number;
  
  // ç¾è‚¡ç‰¹æœ‰
  putCallRatio?: number;
  optionOIChange?: number;
  institutionalFlow?: number;
  vixIndex?: number;
  shortInterest?: number;
}

interface OrderRequest {
  symbol: string;
  side: 'BUY' | 'SELL';
  type: 'MARKET' | 'LIMIT' | 'STOP';
  quantity: number;
  price?: number;
  stopPrice?: number;
  timeInForce?: 'GTC' | 'IOC' | 'FOK';
}

interface OrderResponse {
  orderId: string;
  symbol: string;
  status: 'NEW' | 'FILLED' | 'CANCELLED' | 'REJECTED';
  filledQuantity: number;
  avgPrice?: number;
  timestamp: Date;
}
```

### 2. å¸‚åœºé€‚é…å™¨å®ç°

#### 2.1 Binanceé€‚é…å™¨ (SGæœºæˆ¿)

```typescript
// src/adapters/BinanceAdapter.ts
export class BinanceAdapter implements IExchangeAdapter {
  readonly market: IMarket = {
    marketType: MarketType.CRYPTO,
    tradingHours: {
      timezone: 'UTC',
      sessions: [{ open: '00:00', close: '23:59', days: [0,1,2,3,4,5,6] }]
    },
    symbols: ['BTCUSDT', 'ETHUSDT', 'ADAUSDT'],
    timezone: 'UTC'
  };

  private api: BinanceAPI;
  private ws: BinanceWebSocket;

  constructor(config: BinanceConfig) {
    this.api = new BinanceAPI(config);
    this.ws = new BinanceWebSocket(config);
  }

  async getKlines(symbol: string, timeframe: Timeframe, limit = 500): Promise<Kline[]> {
    const data = await this.api.getKlines(symbol, timeframe, limit);
    return data.map(k => ({
      timestamp: new Date(k[0]),
      open: parseFloat(k[1]),
      high: parseFloat(k[2]),
      low: parseFloat(k[3]),
      close: parseFloat(k[4]),
      volume: parseFloat(k[5]),
      symbol,
      timeframe,
      marketType: MarketType.CRYPTO
    }));
  }

  async getMarketMetrics(symbol: string): Promise<MarketMetrics> {
    const [fundingRate, openInterest, ticker] = await Promise.all([
      this.api.getFundingRate(symbol),
      this.api.getOpenInterest(symbol),
      this.api.getTicker24hr(symbol)
    ]);

    return {
      volume: parseFloat(ticker.volume),
      fundingRate: parseFloat(fundingRate.lastFundingRate),
      openInterest: parseFloat(openInterest.openInterest),
      delta: parseFloat(ticker.delta || 0)
    };
  }

  async placeOrder(order: OrderRequest): Promise<OrderResponse> {
    const response = await this.api.placeOrder({
      symbol: order.symbol,
      side: order.side,
      type: order.type,
      quantity: order.quantity,
      price: order.price,
      timeInForce: order.timeInForce
    });

    return {
      orderId: response.orderId,
      symbol: order.symbol,
      status: response.status as any,
      filledQuantity: parseFloat(response.executedQty),
      avgPrice: parseFloat(response.avgPrice || 0),
      timestamp: new Date(response.transactTime)
    };
  }
}
```

#### 2.2 Aè‚¡é€‚é…å™¨ (CNæœºæˆ¿)

```typescript
// src/adapters/ChinaStockAdapter.ts
export class ChinaStockAdapter implements IExchangeAdapter {
  readonly market: IMarket = {
    marketType: MarketType.CN_STOCK,
    tradingHours: {
      timezone: 'Asia/Shanghai',
      sessions: [
        { open: '09:30', close: '11:30', days: [1,2,3,4,5] },
        { open: '13:00', close: '15:00', days: [1,2,3,4,5] }
      ]
    },
    symbols: ['000001.SZ', '600000.SH', '000002.SZ'],
    timezone: 'Asia/Shanghai'
  };

  private tushareAPI: TushareAPI;
  private efinanceAPI: EFinanceAPI;

  constructor(config: ChinaStockConfig) {
    this.tushareAPI = new TushareAPI(config.tushare);
    this.efinanceAPI = new EFinanceAPI(config.efinance);
  }

  async getKlines(symbol: string, timeframe: Timeframe, limit = 500): Promise<Kline[]> {
    const data = await this.tushareAPI.getKlines(symbol, timeframe, limit);
    return data.map(k => ({
      timestamp: new Date(k.trade_date),
      open: k.open,
      high: k.high,
      low: k.low,
      close: k.close,
      volume: k.vol,
      symbol,
      timeframe,
      marketType: MarketType.CN_STOCK
    }));
  }

  async getMarketMetrics(symbol: string): Promise<MarketMetrics> {
    const [financing, northward, basic] = await Promise.all([
      this.tushareAPI.getFinancingBalance(symbol),
      this.efinanceAPI.getNorthwardFunds(),
      this.tushareAPI.getStockBasic(symbol)
    ]);

    return {
      volume: basic.volume,
      turnover: basic.turnover,
      financingBalance: financing.balance,
      northwardFunds: northward.netInflow,
      volumeRatio: basic.volume / basic.avgVolume,
      peRatio: basic.pe
    };
  }

  async placeOrder(order: OrderRequest): Promise<OrderResponse> {
    // Aè‚¡äº¤æ˜“éœ€è¦é€šè¿‡åˆ¸å•†API
    const response = await this.brokerAPI.placeOrder({
      symbol: order.symbol,
      side: order.side,
      quantity: order.quantity,
      price: order.price,
      orderType: order.type
    });

    return {
      orderId: response.orderId,
      symbol: order.symbol,
      status: response.status,
      filledQuantity: response.filledQuantity,
      avgPrice: response.avgPrice,
      timestamp: new Date(response.timestamp)
    };
  }
}
```

#### 2.3 ç¾è‚¡é€‚é…å™¨ (SGæœºæˆ¿)

```typescript
// src/adapters/USStockAdapter.ts
export class USStockAdapter implements IExchangeAdapter {
  readonly market: IMarket = {
    marketType: MarketType.US_STOCK,
    tradingHours: {
      timezone: 'America/New_York',
      sessions: [
        { open: '09:30', close: '16:00', days: [1,2,3,4,5] }
      ]
    },
    symbols: ['AAPL', 'MSFT', 'GOOGL'],
    timezone: 'America/New_York'
  };

  private alpacaAPI: AlpacaAPI;
  private alphaVantageAPI: AlphaVantageAPI;

  constructor(config: USStockConfig) {
    this.alpacaAPI = new AlpacaAPI(config.alpaca);
    this.alphaVantageAPI = new AlphaVantageAPI(config.alphaVantage);
  }

  async getKlines(symbol: string, timeframe: Timeframe, limit = 500): Promise<Kline[]> {
    const data = await this.alpacaAPI.getBars(symbol, timeframe, limit);
    return data.map(bar => ({
      timestamp: new Date(bar.t),
      open: bar.o,
      high: bar.h,
      low: bar.l,
      close: bar.c,
      volume: bar.v,
      symbol,
      timeframe,
      marketType: MarketType.US_STOCK
    }));
  }

  async getMarketMetrics(symbol: string): Promise<MarketMetrics> {
    const [options, institutional, vix] = await Promise.all([
      this.alphaVantageAPI.getOptionsData(symbol),
      this.alphaVantageAPI.getInstitutionalFlow(symbol),
      this.alphaVantageAPI.getVIX()
    ]);

    return {
      volume: options.volume,
      putCallRatio: options.putCallRatio,
      optionOIChange: options.oiChange,
      institutionalFlow: institutional.netFlow,
      vixIndex: vix.value,
      shortInterest: options.shortInterest
    };
  }

  async placeOrder(order: OrderRequest): Promise<OrderResponse> {
    const response = await this.alpacaAPI.placeOrder({
      symbol: order.symbol,
      qty: order.quantity,
      side: order.side.toLowerCase(),
      type: order.type.toLowerCase(),
      limit_price: order.price,
      stop_price: order.stopPrice,
      time_in_force: order.timeInForce?.toLowerCase()
    });

    return {
      orderId: response.id,
      symbol: order.symbol,
      status: response.status.toUpperCase(),
      filledQuantity: parseFloat(response.filled_qty || 0),
      avgPrice: parseFloat(response.filled_avg_price || 0),
      timestamp: new Date(response.created_at)
    };
  }
}
```

### 3. AIæ¨¡å—è§£è€¦è®¾è®¡

#### 3.1 AIæœåŠ¡ç‹¬ç«‹æ¶æ„

```typescript
// src/services/ai/AIService.ts
interface IAIService {
  readonly provider: AIProvider;
  readonly model: string;
  readonly region: 'SG' | 'CN';
  
  analyzeMarket(marketData: MarketData[]): Promise<MarketAnalysis>;
  generateSignal(strategy: string, context: AnalysisContext): Promise<TradingSignal>;
  assessRisk(portfolio: Portfolio): Promise<RiskAssessment>;
  optimizeParameters(strategy: string, history: BacktestResult[]): Promise<OptimizedParameters>;
}

enum AIProvider {
  CLAUDE = 'claude',
  DEEPSEEK = 'deepseek',
  OPENAI = 'openai'
}

interface MarketAnalysis {
  trend: 'BULLISH' | 'BEARISH' | 'SIDEWAYS';
  strength: number; // 0-100
  confidence: number; // 0-100
  factors: AnalysisFactor[];
  recommendation: string;
}

interface TradingSignal {
  action: 'BUY' | 'SELL' | 'HOLD';
  confidence: number;
  reasoning: string;
  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH';
  expectedReturn: number;
  stopLoss?: number;
  takeProfit?: number;
}
```

#### 3.2 AIæœåŠ¡å®ç°

```typescript
// src/services/ai/ClaudeAIService.ts (SGæœºæˆ¿)
export class ClaudeAIService implements IAIService {
  readonly provider = AIProvider.CLAUDE;
  readonly model = 'claude-3.5-sonnet';
  readonly region = 'SG';

  private client: AnthropicClient;

  constructor(config: ClaudeConfig) {
    this.client = new AnthropicClient({
      apiKey: config.apiKey,
      baseURL: config.baseURL || 'https://api.anthropic.com'
    });
  }

  async analyzeMarket(marketData: MarketData[]): Promise<MarketAnalysis> {
    const prompt = this.buildMarketAnalysisPrompt(marketData);
    
    const response = await this.client.messages.create({
      model: this.model,
      max_tokens: 2000,
      messages: [{ role: 'user', content: prompt }]
    });

    return this.parseMarketAnalysis(response.content[0].text);
  }

  async generateSignal(strategy: string, context: AnalysisContext): Promise<TradingSignal> {
    const prompt = this.buildSignalGenerationPrompt(strategy, context);
    
    const response = await this.client.messages.create({
      model: this.model,
      max_tokens: 1500,
      messages: [{ role: 'user', content: prompt }]
    });

    return this.parseTradingSignal(response.content[0].text);
  }

  private buildMarketAnalysisPrompt(marketData: MarketData[]): string {
    return `
ä½œä¸ºä¸“ä¸šçš„é‡åŒ–äº¤æ˜“åˆ†æå¸ˆï¼Œè¯·åˆ†æä»¥ä¸‹å¸‚åœºæ•°æ®ï¼š

${JSON.stringify(marketData.slice(-50), null, 2)}

è¯·æä¾›ï¼š
1. å¸‚åœºè¶‹åŠ¿åˆ¤æ–­ (BULLISH/BEARISH/SIDEWAYS)
2. è¶‹åŠ¿å¼ºåº¦ (0-100)
3. åˆ†æç½®ä¿¡åº¦ (0-100)
4. å…³é”®å½±å“å› ç´ 
5. äº¤æ˜“å»ºè®®

è¯·ä»¥JSONæ ¼å¼è¿”å›åˆ†æç»“æœã€‚
    `;
  }
}

// src/services/ai/DeepSeekAIService.ts (CNæœºæˆ¿)
export class DeepSeekAIService implements IAIService {
  readonly provider = AIProvider.DEEPSEEK;
  readonly model = 'deepseek-chat';
  readonly region = 'CN';

  private client: DeepSeekClient;

  constructor(config: DeepSeekConfig) {
    this.client = new DeepSeekClient({
      apiKey: config.apiKey,
      baseURL: config.baseURL || 'https://api.deepseek.com'
    });
  }

  async analyzeMarket(marketData: MarketData[]): Promise<MarketAnalysis> {
    // é’ˆå¯¹Aè‚¡å¸‚åœºä¼˜åŒ–çš„åˆ†æé€»è¾‘
    const prompt = this.buildChinaStockAnalysisPrompt(marketData);
    
    const response = await this.client.chat.completions.create({
      model: this.model,
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 2000
    });

    return this.parseMarketAnalysis(response.choices[0].message.content);
  }

  private buildChinaStockAnalysisPrompt(marketData: MarketData[]): string {
    return `
ä½œä¸ºAè‚¡å¸‚åœºä¸“ä¸šåˆ†æå¸ˆï¼Œè¯·åˆ†æä»¥ä¸‹å¸‚åœºæ•°æ®ï¼š

${JSON.stringify(marketData.slice(-50), null, 2)}

è¯·ç‰¹åˆ«å…³æ³¨ï¼š
1. åŒ—å‘èµ„é‡‘æµå‘
2. èèµ„èåˆ¸ä½™é¢å˜åŒ–
3. æ”¿ç­–é¢å½±å“
4. æŠ€æœ¯é¢æŒ‡æ ‡
5. å¸‚åœºæƒ…ç»ª

è¯·ä»¥JSONæ ¼å¼è¿”å›åˆ†æç»“æœã€‚
    `;
  }
}
```

### 4. è·¨æœºæˆ¿é€šä¿¡æœºåˆ¶

#### 4.1 æ¶ˆæ¯é˜Ÿåˆ—æ¶æ„

```typescript
// src/infrastructure/MessagingService.ts
interface IMessagingService {
  publish(topic: string, message: any): Promise<void>;
  subscribe(topic: string, handler: MessageHandler): Promise<void>;
  request(topic: string, data: any, timeout?: number): Promise<any>;
}

interface MessageHandler {
  (message: any): Promise<void>;
}

// Redis Streamså®ç°
export class RedisMessagingService implements IMessagingService {
  private redis: Redis;
  private consumers: Map<string, MessageHandler> = new Map();

  constructor(config: RedisConfig) {
    this.redis = new Redis(config);
  }

  async publish(topic: string, message: any): Promise<void> {
    await this.redis.xadd(topic, '*', 'data', JSON.stringify(message));
  }

  async subscribe(topic: string, handler: MessageHandler): Promise<void> {
    this.consumers.set(topic, handler);
    
    // å¯åŠ¨æ¶ˆè´¹è€…
    this.startConsumer(topic, handler);
  }

  async request(topic: string, data: any, timeout = 5000): Promise<any> {
    const requestId = generateUUID();
    const responseTopic = `${topic}.response.${requestId}`;
    
    // å‘é€è¯·æ±‚
    await this.publish(topic, {
      requestId,
      responseTopic,
      data,
      timestamp: Date.now()
    });

    // ç­‰å¾…å“åº”
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error('Request timeout'));
      }, timeout);

      this.subscribe(responseTopic, (message) => {
        clearTimeout(timeoutId);
        resolve(message.data);
      });
    });
  }

  private async startConsumer(topic: string, handler: MessageHandler): Promise<void> {
    const consumerGroup = `${topic}.group`;
    const consumerName = `${topic}.consumer.${process.pid}`;

    try {
      await this.redis.xgroup('CREATE', topic, consumerGroup, '$', 'MKSTREAM');
    } catch (error) {
      // Group already exists
    }

    while (true) {
      try {
        const messages = await this.redis.xreadgroup(
          'GROUP', consumerGroup, consumerName,
          'COUNT', 1,
          'BLOCK', 1000,
          'STREAMS', topic, '>'
        );

        if (messages && messages.length > 0) {
          for (const [stream, streamMessages] of messages) {
            for (const [id, fields] of streamMessages) {
              const message = JSON.parse(fields.data);
              await handler(message);
              await this.redis.xack(topic, consumerGroup, id);
            }
          }
        }
      } catch (error) {
        console.error('Consumer error:', error);
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  }
}
```

#### 4.2 æ•°æ®åŒæ­¥æœåŠ¡

```typescript
// src/services/DataSyncService.ts
export class DataSyncService {
  private messaging: IMessagingService;
  private adapters: Map<MarketType, IExchangeAdapter>;

  constructor(messaging: IMessagingService, adapters: Map<MarketType, IExchangeAdapter>) {
    this.messaging = messaging;
    this.adapters = adapters;
  }

  async start(): Promise<void> {
    // è®¢é˜…è·¨æœºæˆ¿æ•°æ®åŒæ­¥æ¶ˆæ¯
    await this.messaging.subscribe('data.sync.request', this.handleDataSyncRequest.bind(this));
    await this.messaging.subscribe('data.sync.response', this.handleDataSyncResponse.bind(this));
    
    // å¯åŠ¨å®šæ—¶æ•°æ®åŒæ­¥
    this.startPeriodicSync();
  }

  private async handleDataSyncRequest(message: any): Promise<void> {
    const { marketType, symbol, timeframe, from, to } = message;
    
    try {
      const adapter = this.adapters.get(marketType);
      if (!adapter) {
        throw new Error(`No adapter for market type: ${marketType}`);
      }

      const data = await adapter.getKlines(symbol, timeframe);
      const filteredData = data.filter(k => 
        k.timestamp >= new Date(from) && k.timestamp <= new Date(to)
      );

      await this.messaging.publish('data.sync.response', {
        requestId: message.requestId,
        data: filteredData,
        success: true
      });
    } catch (error) {
      await this.messaging.publish('data.sync.response', {
        requestId: message.requestId,
        error: error.message,
        success: false
      });
    }
  }

  private async startPeriodicSync(): Promise<void> {
    setInterval(async () => {
      // åŒæ­¥å…³é”®å¸‚åœºæ•°æ®
      const syncTasks = [
        this.syncCryptoData(),
        this.syncStockData()
      ];

      await Promise.allSettled(syncTasks);
    }, 60000); // æ¯åˆ†é’ŸåŒæ­¥ä¸€æ¬¡
  }

  private async syncCryptoData(): Promise<void> {
    // SGæœºæˆ¿ -> CNæœºæˆ¿ åŒæ­¥åŠ å¯†è´§å¸æ•°æ®
    const cryptoAdapter = this.adapters.get(MarketType.CRYPTO);
    if (cryptoAdapter) {
      const data = await cryptoAdapter.getKlines('BTCUSDT', '1h', 24);
      await this.messaging.publish('data.crypto.update', {
        marketType: MarketType.CRYPTO,
        data,
        timestamp: Date.now()
      });
    }
  }

  private async syncStockData(): Promise<void> {
    // CNæœºæˆ¿ -> SGæœºæˆ¿ åŒæ­¥Aè‚¡æ•°æ®
    const cnStockAdapter = this.adapters.get(MarketType.CN_STOCK);
    if (cnStockAdapter) {
      const data = await cnStockAdapter.getKlines('000001.SZ', '1h', 24);
      await this.messaging.publish('data.stock.update', {
        marketType: MarketType.CN_STOCK,
        data,
        timestamp: Date.now()
      });
    }
  }
}
```

### 5. ç»Ÿä¸€é…ç½®ç®¡ç†

#### 5.1 å¤šç¯å¢ƒé…ç½®

```typescript
// src/config/ConfigManager.ts
interface SystemConfig {
  environment: 'development' | 'staging' | 'production';
  region: 'SG' | 'CN';
  
  // æ•°æ®åº“é…ç½®
  database: {
    mysql: MySQLConfig;
    redis: RedisConfig;
    influxdb?: InfluxDBConfig;
    mongodb?: MongoDBConfig;
  };
  
  // å¸‚åœºé…ç½®
  markets: {
    crypto: MarketConfig;
    cnStock: MarketConfig;
    usStock: MarketConfig;
  };
  
  // AIæœåŠ¡é…ç½®
  ai: {
    providers: {
      claude: ClaudeConfig;
      deepseek: DeepSeekConfig;
    };
    defaultProvider: AIProvider;
  };
  
  // æ¶ˆæ¯é˜Ÿåˆ—é…ç½®
  messaging: {
    redis: RedisConfig;
    topics: string[];
  };
  
  // ç›‘æ§é…ç½®
  monitoring: {
    prometheus: PrometheusConfig;
    grafana: GrafanaConfig;
  };
}

// SGæœºæˆ¿é…ç½®
const sgConfig: SystemConfig = {
  environment: 'production',
  region: 'SG',
  
  database: {
    mysql: {
      host: 'sg-mysql-cluster.internal',
      port: 3306,
      database: 'trading_sg',
      username: 'trading_user',
      password: process.env.MYSQL_PASSWORD
    },
    redis: {
      host: 'sg-redis-cluster.internal',
      port: 6379,
      password: process.env.REDIS_PASSWORD
    }
  },
  
  markets: {
    crypto: {
      enabled: true,
      adapter: 'BinanceAdapter',
      symbols: ['BTCUSDT', 'ETHUSDT', 'ADAUSDT'],
      tradingHours: '24/7'
    },
    usStock: {
      enabled: true,
      adapter: 'USStockAdapter',
      symbols: ['AAPL', 'MSFT', 'GOOGL'],
      tradingHours: '09:30-16:00 ET'
    },
    cnStock: {
      enabled: false, // SGæœºæˆ¿ä¸ç›´æ¥äº¤æ˜“Aè‚¡
      adapter: 'ChinaStockAdapter'
    }
  },
  
  ai: {
    providers: {
      claude: {
        apiKey: process.env.CLAUDE_API_KEY,
        baseURL: 'https://api.anthropic.com',
        model: 'claude-3.5-sonnet'
      },
      deepseek: {
        apiKey: process.env.DEEPSEEK_API_KEY,
        baseURL: 'https://api.deepseek.com',
        model: 'deepseek-chat'
      }
    },
    defaultProvider: AIProvider.CLAUDE
  },
  
  messaging: {
    redis: {
      host: 'sg-redis-cluster.internal',
      port: 6379,
      password: process.env.REDIS_PASSWORD
    },
    topics: [
      'data.sync.request',
      'data.sync.response',
      'ai.analysis.request',
      'ai.analysis.response',
      'trading.signal',
      'risk.alert'
    ]
  }
};

// CNæœºæˆ¿é…ç½®
const cnConfig: SystemConfig = {
  environment: 'production',
  region: 'CN',
  
  database: {
    mysql: {
      host: 'cn-mysql-cluster.internal',
      port: 3306,
      database: 'trading_cn',
      username: 'trading_user',
      password: process.env.MYSQL_PASSWORD
    },
    redis: {
      host: 'cn-redis-cluster.internal',
      port: 6379,
      password: process.env.REDIS_PASSWORD
    }
  },
  
  markets: {
    crypto: {
      enabled: false, // CNæœºæˆ¿ä¸ç›´æ¥äº¤æ˜“åŠ å¯†è´§å¸
      adapter: 'BinanceAdapter'
    },
    usStock: {
      enabled: false, // CNæœºæˆ¿ä¸ç›´æ¥äº¤æ˜“ç¾è‚¡
      adapter: 'USStockAdapter'
    },
    cnStock: {
      enabled: true,
      adapter: 'ChinaStockAdapter',
      symbols: ['000001.SZ', '600000.SH', '000002.SZ'],
      tradingHours: '09:30-11:30,13:00-15:00'
    }
  },
  
  ai: {
    providers: {
      deepseek: {
        apiKey: process.env.DEEPSEEK_API_KEY,
        baseURL: 'https://api.deepseek.com',
        model: 'deepseek-chat'
      }
    },
    defaultProvider: AIProvider.DEEPSEEK
  },
  
  messaging: {
    redis: {
      host: 'cn-redis-cluster.internal',
      port: 6379,
      password: process.env.REDIS_PASSWORD
    },
    topics: [
      'data.sync.request',
      'data.sync.response',
      'ai.analysis.request',
      'ai.analysis.response',
      'trading.signal',
      'risk.alert'
    ]
  }
};

export class ConfigManager {
  private static instance: ConfigManager;
  private config: SystemConfig;

  private constructor() {
    this.loadConfig();
  }

  static getInstance(): ConfigManager {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager();
    }
    return ConfigManager.instance;
  }

  private loadConfig(): void {
    const region = process.env.REGION as 'SG' | 'CN';
    
    switch (region) {
      case 'SG':
        this.config = sgConfig;
        break;
      case 'CN':
        this.config = cnConfig;
        break;
      default:
        throw new Error(`Unsupported region: ${region}`);
    }
  }

  getConfig(): SystemConfig {
    return this.config;
  }

  getMarketConfig(marketType: MarketType): MarketConfig {
    switch (marketType) {
      case MarketType.CRYPTO:
        return this.config.markets.crypto;
      case MarketType.CN_STOCK:
        return this.config.markets.cnStock;
      case MarketType.US_STOCK:
        return this.config.markets.usStock;
      default:
        throw new Error(`Unsupported market type: ${marketType}`);
    }
  }

  getAIProvider(provider: AIProvider): any {
    return this.config.ai.providers[provider];
  }
}
```

### 6. æœåŠ¡å¯åŠ¨å’Œéƒ¨ç½²

#### 6.1 ä¸»æœåŠ¡å¯åŠ¨å™¨

```typescript
// src/Application.ts
export class TradingSystemApplication {
  private config: SystemConfig;
  private adapters: Map<MarketType, IExchangeAdapter>;
  private aiService: IAIService;
  private messagingService: IMessagingService;
  private dataSyncService: DataSyncService;

  async start(): Promise<void> {
    console.log(`ğŸš€ Starting Trading System in ${this.config.region} region...`);
    
    // 1. åˆå§‹åŒ–é…ç½®
    this.config = ConfigManager.getInstance().getConfig();
    
    // 2. åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
    await this.initializeDatabase();
    
    // 3. åˆå§‹åŒ–æ¶ˆæ¯é˜Ÿåˆ—
    await this.initializeMessaging();
    
    // 4. åˆå§‹åŒ–å¸‚åœºé€‚é…å™¨
    await this.initializeAdapters();
    
    // 5. åˆå§‹åŒ–AIæœåŠ¡
    await this.initializeAIService();
    
    // 6. åˆå§‹åŒ–æ•°æ®åŒæ­¥æœåŠ¡
    await this.initializeDataSync();
    
    // 7. å¯åŠ¨æ ¸å¿ƒæœåŠ¡
    await this.startCoreServices();
    
    console.log('âœ… Trading System started successfully!');
  }

  private async initializeAdapters(): Promise<void> {
    this.adapters = new Map();
    
    // æ ¹æ®é…ç½®åˆå§‹åŒ–é€‚é…å™¨
    if (this.config.markets.crypto.enabled) {
      const binanceAdapter = new BinanceAdapter(this.config.markets.crypto);
      this.adapters.set(MarketType.CRYPTO, binanceAdapter);
    }
    
    if (this.config.markets.cnStock.enabled) {
      const cnStockAdapter = new ChinaStockAdapter(this.config.markets.cnStock);
      this.adapters.set(MarketType.CN_STOCK, cnStockAdapter);
    }
    
    if (this.config.markets.usStock.enabled) {
      const usStockAdapter = new USStockAdapter(this.config.markets.usStock);
      this.adapters.set(MarketType.US_STOCK, usStockAdapter);
    }
  }

  private async initializeAIService(): Promise<void> {
    const provider = this.config.ai.defaultProvider;
    const providerConfig = this.config.ai.providers[provider];
    
    switch (provider) {
      case AIProvider.CLAUDE:
        this.aiService = new ClaudeAIService(providerConfig);
        break;
      case AIProvider.DEEPSEEK:
        this.aiService = new DeepSeekAIService(providerConfig);
        break;
      default:
        throw new Error(`Unsupported AI provider: ${provider}`);
    }
  }

  private async startCoreServices(): Promise<void> {
    // å¯åŠ¨ç­–ç•¥å¼•æ“
    const strategyEngine = new StrategyEngine(this.adapters, this.aiService);
    await strategyEngine.start();
    
    // å¯åŠ¨é£é™©ç®¡ç†
    const riskManager = new RiskManager(this.adapters);
    await riskManager.start();
    
    // å¯åŠ¨å›æµ‹å¼•æ“
    const backtestEngine = new BacktestEngine(this.adapters);
    await backtestEngine.start();
    
    // å¯åŠ¨è®¢å•ç®¡ç†
    const orderManager = new OrderManager(this.adapters);
    await orderManager.start();
  }
}

// å¯åŠ¨åº”ç”¨
const app = new TradingSystemApplication();
app.start().catch(console.error);
```

#### 6.2 Dockeréƒ¨ç½²é…ç½®

```yaml
# docker-compose.sg.yml (SGæœºæˆ¿)
version: '3.8'
services:
  trading-system-sg:
    build: .
    environment:
      - REGION=SG
      - NODE_ENV=production
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - CLAUDE_API_KEY=${CLAUDE_API_KEY}
      - DEEPSEEK_API_KEY=${DEEPSEEK_API_KEY}
    ports:
      - "3000:3000"
    depends_on:
      - mysql-sg
      - redis-sg
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  mysql-sg:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
      - MYSQL_DATABASE=trading_sg
    volumes:
      - mysql-sg-data:/var/lib/mysql
    restart: unless-stopped

  redis-sg:
    image: redis:7-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis-sg-data:/data
    restart: unless-stopped

volumes:
  mysql-sg-data:
  redis-sg-data:
```

```yaml
# docker-compose.cn.yml (CNæœºæˆ¿)
version: '3.8'
services:
  trading-system-cn:
    build: .
    environment:
      - REGION=CN
      - NODE_ENV=production
      - MYSQL_PASSWORD=${MYSQL_PASSWORD}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - DEEPSEEK_API_KEY=${DEEPSEEK_API_KEY}
      - TUSHARE_TOKEN=${TUSHARE_TOKEN}
    ports:
      - "3000:3000"
    depends_on:
      - mysql-cn
      - redis-cn
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  mysql-cn:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}
      - MYSQL_DATABASE=trading_cn
    volumes:
      - mysql-cn-data:/var/lib/mysql
    restart: unless-stopped

  redis-cn:
    image: redis:7-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis-cn-data:/data
    restart: unless-stopped

volumes:
  mysql-cn-data:
  redis-cn-data:
```

---

## ğŸ“Š å®æ–½è®¡åˆ’

### é˜¶æ®µ1: æ ¸å¿ƒæ¶æ„æ­å»º (2-3å‘¨)
1. âœ… è®¾è®¡é€šç”¨äº¤æ˜“ç³»ç»Ÿæ¥å£
2. âœ… å®ç°å¸‚åœºé€‚é…å™¨æ¨¡å¼
3. âœ… åˆ›å»ºç»Ÿä¸€æ•°æ®æ¨¡å‹
4. âœ… æ­å»ºæ¶ˆæ¯é˜Ÿåˆ—åŸºç¡€è®¾æ–½

### é˜¶æ®µ2: å¸‚åœºé€‚é…å™¨å¼€å‘ (3-4å‘¨)
1. âœ… å®Œå–„Binanceé€‚é…å™¨
2. âœ… å¼€å‘Aè‚¡é€‚é…å™¨ (Tushare + ä¸œæ–¹è´¢å¯Œ)
3. âœ… å¼€å‘ç¾è‚¡é€‚é…å™¨ (Alpaca + Alpha Vantage)
4. âœ… å®ç°æ•°æ®æ ¼å¼æ ‡å‡†åŒ–

### é˜¶æ®µ3: AIæ¨¡å—è§£è€¦ (2-3å‘¨)
1. âœ… è®¾è®¡AIæœåŠ¡æ¥å£
2. âœ… å®ç°Claude AIæœåŠ¡ (SGæœºæˆ¿)
3. âœ… å®ç°DeepSeek AIæœåŠ¡ (CNæœºæˆ¿)
4. âœ… å»ºç«‹AIæœåŠ¡é€šä¿¡æœºåˆ¶

### é˜¶æ®µ4: è·¨æœºæˆ¿éƒ¨ç½² (2-3å‘¨)
1. âœ… é…ç½®å¤šç¯å¢ƒç®¡ç†
2. âœ… å®ç°æ•°æ®åŒæ­¥æœåŠ¡
3. âœ… éƒ¨ç½²SGæœºæˆ¿æœåŠ¡
4. âœ… éƒ¨ç½²CNæœºæˆ¿æœåŠ¡

### é˜¶æ®µ5: æµ‹è¯•ä¸ä¼˜åŒ– (2-3å‘¨)
1. âœ… å•å…ƒæµ‹è¯•è¦†ç›–
2. âœ… é›†æˆæµ‹è¯•éªŒè¯
3. âœ… æ€§èƒ½ä¼˜åŒ–
4. âœ… ç›‘æ§å‘Šè­¦å®Œå–„

---

## ğŸ¯ é¢„æœŸæ•ˆæœ

### æŠ€æœ¯ä¼˜åŠ¿
- **é«˜åº¦æ¨¡å—åŒ–**: æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ä¸å¸‚åœºè§£è€¦
- **AIç‹¬ç«‹æœåŠ¡**: AIæ¨¡å—å®Œå…¨è§£è€¦ï¼Œæ”¯æŒå¤šæä¾›å•†
- **è·¨æœºæˆ¿éƒ¨ç½²**: æ”¯æŒSG/CNæœºæˆ¿ç‹¬ç«‹éƒ¨ç½²
- **ç»Ÿä¸€æ¥å£**: å¤šå¸‚åœºç»Ÿä¸€äº¤æ˜“æ¥å£

### ä¸šåŠ¡ä»·å€¼
- **å¤šå¸‚åœºè¦†ç›–**: åŠ å¯†è´§å¸ + Aè‚¡ + ç¾è‚¡
- **é£é™©åˆ†æ•£**: è·¨å¸‚åœºé…ç½®é™ä½é£é™©
- **AIå¢å¼º**: å¤šAIæä¾›å•†æå‡åˆ†æè´¨é‡
- **æ‰©å±•æ€§å¼º**: æ˜“äºæ·»åŠ æ–°å¸‚åœºå’Œæ–°åŠŸèƒ½

è¿™ä¸ªæ¶æ„è®¾è®¡å®Œå…¨åŸºäºç°æœ‰çš„trading-system-v2ç³»ç»Ÿï¼Œé€šè¿‡æŠ½è±¡åŒ–å’Œæ¨¡å—åŒ–æ”¹é€ ï¼Œå®ç°äº†å¤šå¸‚åœºæ”¯æŒå’ŒAIæ¨¡å—è§£è€¦ï¼ŒåŒæ—¶è€ƒè™‘äº†è·¨æœºæˆ¿éƒ¨ç½²çš„å¤æ‚éœ€æ±‚ã€‚
