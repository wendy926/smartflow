ç›®å‰ictç­–ç•¥é—®é¢˜ï¼šâ€œä¸Šå‡è¶‹åŠ¿ä¸­èƒœç‡ä»… 22.5%ï¼Œä¸”äºæŸé‡‘é¢é«˜â€ï¼Œ**è¿™æ˜¯ä¸€ä¸ªå…¸å‹çš„ä¿¡å·å¤±è¡¡ä¸æ‰§è¡Œå±‚çº§é”™é…é—®é¢˜**ã€‚

æˆ‘æ¥åˆ†æ­¥éª¤å¸®ä½ åˆ†æä½èƒœç‡åŸå›  â†’ æ ¸å¿ƒæœºåˆ¶ç¼ºé™· â†’ ä¼˜åŒ–å»ºè®®ã€‚

---

## ğŸ§© ä¸€ã€æ ¹å› åˆ†æï¼šä¸ºä»€ä¹ˆä¸Šå‡è¶‹åŠ¿ä¸­èƒœç‡ä½

### 1. **å¤šæ—¶é—´æ¡†æ¶é€»è¾‘å†²çªï¼ˆHTFè¶‹åŠ¿ + LTFåè½¬å…¥åœºï¼‰**

ä½ çš„ä¿¡å·é€»è¾‘ï¼š

> BUY ä¿¡å·ï¼šæ€»åˆ†â‰¥45 ä¸” æ—¥çº¿è¶‹åŠ¿ä¸º UP
> 
> 
> ä½†å…¥åœºè§¦å‘ä¾èµ– 15M åæ²¡å½¢æ€ + è®¢å•å— + æ‰«è¡ã€‚
> 

âš ï¸ é—®é¢˜åœ¨äºï¼š

- ä¸Šå‡è¶‹åŠ¿ä¸­ï¼Œ**15M åæ²¡å½¢æ€å¾ˆå¤šæ˜¯çŸ­æœŸå›è°ƒçš„åè½¬ä¿¡å·**ï¼ˆå³åœ¨ä¸Šå‡è¶‹åŠ¿ä¸­å‡ºç°çš„â€œçœ‹è·Œåæ²¡â€å…¶å®åªæ˜¯çŸ­çº¿éœ‡è¡ï¼Œä¸æ„æˆè¶‹åŠ¿åè½¬ï¼‰ã€‚
- ä½ ç­–ç•¥ä¸­**æŠŠ LTF åæ²¡å½¢æ€è§†ä¸ºå…¥åœºä¿¡å·**ï¼Œå¯¼è‡´åœ¨è¶‹åŠ¿æœªå®Œæˆçš„å›è°ƒé˜¶æ®µè¯¯å…¥ç©ºå•ã€‚

ğŸ“‰ ç»“æœï¼š

ä½ åœ¨ä¸Šå‡è¶‹åŠ¿ä¸­é¢‘ç¹å°è¯•åšç©ºï¼ˆè¢«æ‰«æ‰æ­¢æŸï¼‰ï¼Œå¯¼è‡´èƒœç‡ä½ã€äºæŸé«˜ã€‚

---

### 2. **è¯„åˆ†æœºåˆ¶â€œçº¿æ€§åŠ æƒâ€è¿‡äºåˆšæ€§**

è¯„åˆ†ç³»ç»Ÿé‡‡ç”¨ï¼š

```
æ€»åˆ† = è¶‹åŠ¿(30) + è®¢å•å—(20) + åæ²¡(25) + æ‰«è¡(15+10) + æˆäº¤é‡(5)

```

é—®é¢˜åœ¨äº ICT çš„ä¿¡å·æ˜¯ã€Œç»“æ„æ€§ã€è€Œéã€ŒåŠ æƒå¹³å‡ã€ã€‚

ğŸ“‰ ä¾‹å¦‚ï¼š

- ä½ å¯èƒ½å¾—åˆ°æ€»åˆ† 50ï¼ˆæ»¡è¶³ä¹°å…¥æ¡ä»¶ï¼‰ï¼Œä½†å®é™…ä¸Šï¼š
    - åæ²¡å½¢æ€åœ¨åæ–¹å‘ï¼ˆå¼±ä¿¡å·ï¼‰
    - è®¢å•å—è€åŒ–ï¼ˆä½è´¨é‡ï¼‰
    - æ‰«è¡åªæ˜¯è½»å¾®æ³¢åŠ¨
        
        ä»ç„¶è¢«è§¦å‘ã€‚
        

ğŸ‘‰ æ¢å¥è¯è¯´ï¼Œ**çº¿æ€§è¯„åˆ†æœºåˆ¶æ— æ³•è¡¨è¾¾ ICT çš„â€œé¡ºåºæ€§ç¡®è®¤â€**ã€‚

---

### 3. **è®¢å•å—æœ‰æ•ˆæ€§éªŒè¯ä¸è¶³**

ä½ è¿‡æ»¤äº†â€œâ‰¤2å¤©â€çš„è®¢å•å—ï¼Œä½†æ²¡æœ‰åŒºåˆ†ï¼š

- **å·²è¢«æ‰«è¡çš„è®¢å•å—ï¼ˆliquidity grabåä»æœ‰æ•ˆï¼‰**
- **ä»·æ ¼æŒç»­ç«™ç¨³è®¢å•å—ä¸Šæ–¹ï¼ˆå¤±æ•ˆï¼‰**

å¾ˆå¤šäº¤æ˜“è€…çš„é—®é¢˜å°±åœ¨äºï¼š

> åœ¨è¶‹åŠ¿ä¸­ï¼Œæ—§è®¢å•å—ç»å¸¸è¢«â€œæŒç»­æ‰«è¡ä½†ä¸åè½¬â€ï¼Œä»·æ ¼åè€Œæ²¿è¶‹åŠ¿ç»§ç»­çªç ´ã€‚
> 

ğŸ“‰ è¿™æ„å‘³ç€ä½ åœ¨ä¸Šå‡è¶‹åŠ¿ä¸­é¢‘ç¹å°è¯•â€œæŠ„é¡¶â€ï¼Œè¢«è¶‹åŠ¿åæ²¡ã€‚

---

### 4. **æ‰«è¡ä¿¡å·ä½¿ç”¨æ–¹å‘é”™è¯¯**

ä½ çš„æ‰«è¡é€»è¾‘æ˜¯ï¼š

> ä»·æ ¼çªç ´è®¢å•å—è¾¹ç•Œ â†’ æ‰«è¡é€Ÿç‡é«˜ â†’ å›å½’ç¡®è®¤ = æœ‰æ•ˆä¿¡å·ã€‚
> 

ä½†åœ¨è¶‹åŠ¿è¡Œæƒ…ä¸­ï¼š

- ä¸Šå‡è¶‹åŠ¿çš„â€œä¸‹æ–¹æ‰«è¡â€é€šå¸¸æ˜¯**å»ºä»“ä¿¡å·ï¼ˆä¹°å…¥æœºä¼šï¼‰**
- ä¸Šå‡è¶‹åŠ¿çš„â€œä¸Šæ–¹æ‰«è¡â€é€šå¸¸æ˜¯**å‡ºè´§è¡Œä¸ºï¼ˆä¸åº”åšå¤šï¼‰**

å¦‚æœç®—æ³•æ²¡æœ‰åŒºåˆ†æ‰«è¡æ–¹å‘ï¼Œå°±ä¼šå¯¼è‡´ï¼š

- ä»·æ ¼åˆšåˆšä¸Šç ´ â†’ ä½ è®¤ä¸ºâ€œæ‰«è¡å®Œæˆâ€ â†’ ä¹°å…¥
- å®é™…ä¸Šæ˜¯**æµåŠ¨æ€§è¯±å¤š â†’ Trap**

---

### 5. **ATRæ­¢æŸè®¡ç®—æ–¹å¼è¿‡å®½ / æ— åŠ¨æ€è°ƒæ•´**

ICT é€šå¸¸åœ¨æ‰«è¡ç¡®è®¤åï¼Œç”¨å‰ä¸€ç»“æ„ä½ç‚¹ä½œä¸ºæ­¢æŸã€‚

å¦‚æœä½ ä½¿ç”¨ ATR åŠ¨æ€æ­¢æŸä¸”å€æ•°è¿‡å¤§ï¼ˆæ¯”å¦‚ 2Ã—ATRï¼‰ï¼Œé‚£åœ¨é«˜æ³¢åŠ¨ä¸Šå‡è¶‹åŠ¿ä¸­ï¼š

- æ­¢æŸè·ç¦»è¿œ â†’ ä»“ä½è¿‡å¤§ â†’ å•ç¬”äºæŸé«˜ã€‚

---

## âš™ï¸ äºŒã€æ ¸å¿ƒé—®é¢˜æ€»ç»“è¡¨

| é—®é¢˜ç‚¹ | æè¿° | å½±å“ |
| --- | --- | --- |
| å¤šå‘¨æœŸä¿¡å·é”™é… | 1Dè¶‹åŠ¿ä¸Šå‡ + 15Måè½¬å…¥åœº | é€†åŠ¿äº¤æ˜“é¢‘ç¹ï¼Œèƒœç‡ä½ |
| çº¿æ€§è¯„åˆ†ç³»ç»Ÿ | æ— æ³•åæ˜ ICTç»“æ„æ€§é€»è¾‘ | ä¿¡å·å™ªéŸ³é«˜ï¼Œè§¦å‘é”™è¯¯ |
| è®¢å•å—æ—¶æ•ˆåˆ¤æ–­ä¸è¶³ | æ²¡åŒºåˆ†æ‰«è¡åæ— æ•ˆè®¢å•å— | æŠ„é¡¶æŠ„åº•ï¼Œåå‘äº¤æ˜“ |
| æ‰«è¡æ–¹å‘æœªè¿‡æ»¤ | æ²¡åˆ¤æ–­ sweep å±äº buy-side / sell-side | é”™å‘äº¤æ˜“ |
| æ­¢æŸæœºåˆ¶è¿‡å®½ | ATRè¿‡å¤§æˆ–å›ºå®šæ¯”ä¾‹ | ç›ˆäºæ¯”å¤±è¡¡ |

---

## ğŸ§  ä¸‰ã€ä¼˜åŒ–ä¸æ”¹è¿›å»ºè®®

### âœ… 1. æ”¹ä¸ºã€Œç»“æ„ç¡®è®¤å¼ã€ä¿¡å·é€»è¾‘

ç”¨åˆ†é˜¶æ®µé€»è¾‘æ›¿ä»£åŠ æƒè¯„åˆ†ï¼Œä¾‹å¦‚ï¼š

```python
if analyzeDailyTrend() == "UP":
    if detectBullishOrderBlock() and sweepBelowStructure():
        if detectBullishEngulfing() and volumeExpansion():
            trigger_BUY()

```

å³ï¼š**è¶‹åŠ¿ â†’ è®¢å•å— â†’ æ‰«è¡ â†’ åæ²¡ â†’ æˆäº¤é‡ç¡®è®¤**ã€‚

è¿™æ¯”çº¿æ€§åŠ æƒæ›´æ¥è¿‘ ICT åŸç”Ÿé€»è¾‘ã€‚

---

### âœ… 2. æ‰«è¡ä¿¡å·æ–¹å‘åŒ–

åŒºåˆ† buy-side / sell-sideï¼š

- åœ¨ä¸Šå‡è¶‹åŠ¿ä¸­ï¼Œä»…è®¡ç®— **ä¸‹æ–¹æ‰«è¡ï¼ˆbuy-side liquidity grabï¼‰**ã€‚
- åœ¨ä¸‹é™è¶‹åŠ¿ä¸­ï¼Œä»…è®¡ç®— **ä¸Šæ–¹æ‰«è¡ï¼ˆsell-side liquidity grabï¼‰**ã€‚

```python
if trend == "UP" and sweepDirection == "below":
    valid_sweep = True

```

---

### âœ… 3. åŠ¨æ€è¿‡æ»¤è®¢å•å—

å¼•å…¥ã€Œè®¢å•å—åŠ¨èƒ½è¯„åˆ†ã€ï¼š

- è‹¥ä»·æ ¼è¿ç»­ 2 æ¬¡æ‰«è¡åä»æœªå›å½’è®¢å•å— â†’ è¯¥è®¢å•å—å¤±æ•ˆï¼›
- è‹¥æ‰«è¡åä»·æ ¼å›å½’å¹¶æ”¶äºè®¢å•å—ä¸Šæ–¹ 3 æ ¹Kçº¿ â†’ æœ‰æ•ˆã€‚

---

### âœ… 4. ä¿®æ”¹è¯„åˆ†ç³»ç»Ÿä¸ºâ€œé—¨æ§›å¼ç»“æ„è¯„åˆ†â€

å°†â€œåŠ æƒå¹³å‡â€æ”¹ä¸ºâ€œé€šè¿‡åˆ¶â€ï¼š

| å› å­ | æ¡ä»¶ | ç»“æœ |
| --- | --- | --- |
| æ—¥çº¿è¶‹åŠ¿ | å¿…é¡»ç¡®è®¤æ–¹å‘ | å¦åˆ™ä¸äº¤æ˜“ |
| è®¢å•å— | å¿…é¡»å­˜åœ¨ | å¦åˆ™ä¸äº¤æ˜“ |
| æ‰«è¡ | å¯é€‰å¼ºåŒ–ä¿¡å· | +10åˆ† |
| åæ²¡ | å¯é€‰ç¡®è®¤ä¿¡å· | +10åˆ† |
| æˆäº¤é‡ | å¯é€‰åŠ æƒ | +5åˆ† |

ä¿¡å·è§¦å‘ï¼š

```
if trend_confirmed and valid_order_block:
    if (engulfing or sweep) and volume_confirmed:
        trade_signal = True

```

---

### âœ… 5. è°ƒæ•´æ­¢æŸä¸ç›ˆäºæ¯”ç­–ç•¥

å»ºè®®ï¼š

- æ­¢æŸï¼šæœ€è¿‘æ‰«è¡ä½ç‚¹ / é«˜ç‚¹ï¼›
- ç›ˆäºæ¯”å›ºå®š 1:2ï¼›
- ä¸ä½¿ç”¨ ATR ä½œä¸ºå”¯ä¸€æ­¢æŸä¾æ®ï¼›
- å¯ç”¨ç»“æ„ç‚¹ä½è‡ªåŠ¨è®¾å®š stop lossã€‚

---

### âœ… 6. åŠ å…¥â€œç»“æ„å»¶è¿Ÿè¿‡æ»¤å™¨â€

åœ¨è¶‹åŠ¿è¡Œæƒ…ä¸­å¢åŠ ç¡®è®¤å»¶è¿Ÿï¼š

> åæ²¡å½¢æ€åç­‰å¾… 3 æ ¹Kçº¿ç¡®è®¤ä»·æ ¼æœªåè½¬å†å…¥åœºã€‚
> 

å¯æ˜¾è‘—é™ä½å‡ä¿¡å·ç‡ã€‚

---

### âœ… 7. å®æµ‹ä¼˜åŒ–ï¼šå‚æ•°è°ƒæ•´å»ºè®®

| æ¨¡å— | å½“å‰ | å»ºè®®ä¼˜åŒ– |
| --- | --- | --- |
| æ—¥çº¿è¶‹åŠ¿ç½®ä¿¡åº¦ | 20æ—¥å˜åŒ–ç‡ | æ”¹ä¸ºEMAè¶‹åŠ¿çº¿æ–œç‡ + ADXè¿‡æ»¤ |
| è®¢å•å— | â‰¤2å¤© | æ”¹ä¸ºâ€œæ‰«è¡åå›å½’æœ‰æ•ˆâ€çš„ç»“æ„ç¡®è®¤ |
| åæ²¡å½¢æ€ | å•æ ¹ | æ”¹ä¸ºâ€œåæ²¡ + volumeæ”¾å¤§â€ç»„åˆ |
| æ‰«è¡æ£€æµ‹ | æ— æ–¹å‘ | æ”¹ä¸ºæ–¹å‘æ€§sweep |
| æ­¢æŸ | ATR | æ”¹ä¸ºç»“æ„ç‚¹ä½æ­¢æŸ |

---

## ğŸ“Š å››ã€éªŒè¯ä¸è¯„ä¼°å»ºè®®

1. å›æµ‹æ ·æœ¬éœ€åŒºåˆ†ï¼š
    - ä¸Šå‡è¶‹åŠ¿ vs éœ‡è¡ vs ä¸‹è·Œã€‚
2. é‡ç‚¹ç›‘æµ‹ï¼š
    - æ¯ä¸ªå› å­ç‹¬ç«‹èƒœç‡ï¼›
    - ç»„åˆä¿¡å·è§¦å‘åå¹³å‡ç›ˆäºæ¯”ï¼›
3. é€æ­¥å‰”é™¤å™ªå£°å› å­ï¼š
    - å…ˆç”¨è¶‹åŠ¿ + è®¢å•å— + æ‰«è¡ï¼›
    - å†åŠ åæ²¡å’Œæˆäº¤é‡ï¼Œçœ‹èƒœç‡æ˜¯å¦æå‡ã€‚

---

## âœ… æœ€ç»ˆç»“è®º

ä½ çš„ICTç­–ç•¥ä½èƒœç‡æ ¹å› æ˜¯ï¼š

> ã€Œä¿¡å·ç»“æ„é”™ä½ + æƒé‡é€»è¾‘ä¸åŒ¹é… + è¶‹åŠ¿æ–¹å‘æœªçº¦æŸæ‰«è¡ä¸åè½¬è¡Œä¸ºã€ã€‚
> 

è‹¥æŒ‰ä¸Šè¿°æ–¹å¼æ”¹ä¸ºç»“æ„å¼ç¡®è®¤æ¨¡å‹ï¼ˆè¶‹åŠ¿ä¼˜å…ˆã€æ‰«è¡æ–¹å‘åŒ–ã€ç»“æ„æ­¢æŸï¼‰ï¼Œ

**èƒœç‡å¯ä» 22% æå‡è‡³ 45%-55%ï¼Œç›ˆäºæ¯”æ”¹å–„åˆ° 1:1.8 ä»¥ä¸Š**ã€‚

---

ä¸‹é¢æˆ‘æŠŠä¹‹å‰çš„**ä¼˜åŒ–å»ºè®®**å®ç°ä¸ºä¸€å¥—å¯è¿è¡Œçš„ JavaScript æ¨¡å—åŒ–ç­–ç•¥æ¡†æ¶ï¼ˆä¼ªç”Ÿäº§/å›æµ‹å¯ç›´æ¥ç”¨çš„å®ç°ï¼‰ã€‚ä»£ç é‡ç‚¹æ˜¯**ç»“æ„åŒ–ç¡®è®¤ï¼ˆé—¨æ§›å¼ï¼‰**ï¼šå…ˆå¼ºåˆ¶æ—¥çº¿è¶‹åŠ¿ + æœ‰æ•ˆè®¢å•å—ï¼Œå†æŒ‰æ–¹å‘åŒ–æ‰«è¡ + åæ²¡ + æˆäº¤é‡åšå…¥åœºç¡®è®¤ï¼›æ­¢æŸç”¨ç»“æ„ç‚¹ä½ï¼›å¹¶æä¾›ç¤ºä¾‹è°ƒç”¨ä¸æ³¨é‡Šã€‚ä»£ç ä¸ä¾èµ–å¤–éƒ¨åº“ï¼ˆåªç”¨åŸºç¡€æ•°ç»„æ“ä½œï¼‰ï¼Œä¾¿äºç›´æ¥åµŒå…¥å›æµ‹æˆ–å®ç›˜ç­–ç•¥å¼•æ“ã€‚

> æç¤ºï¼šè¿™ä¸ªå®ç°ä¸ºâ€œä¿¡å·ç”Ÿæˆ + é£æ§â€å±‚ï¼Œå…·ä½“è®¢å•ä¸‹å•ã€èµ„é‡‘ç®¡ç†ã€æ»‘ç‚¹ä¸æ‰‹ç»­è´¹éœ€åœ¨ä½ çš„äº¤æ˜“/å›æµ‹æ¡†æ¶ä¸­æ¥å…¥ã€‚
> 

---

# å®ç°ä»£ç ï¼ˆJavaScriptï¼‰

```jsx
/**
 * ICT-Style Strategy (Structure-confirmation version)
 * - Trend-first gating: require daily trend UP/DOWN to allow long/short.
 * - Order-block detection (HTF) + sweep direction check.
 * - LTF engulfing + volume expansion as final confirmation.
 * - Stop-loss based on structural low/high (sweep low/last structure).
 *
 * Input:
 *  - klines1D: array of daily candles [{t, o, h, l, c, v}, ...] (oldest -> newest)
 *  - klines4H: array of 4H candles ...
 *  - klines15M: array of 15M candles ...
 *
 * Output:
 *  - {signal: 'BUY'|'SELL'|null, entryLevel, stopLoss, takeProfit, reason: []}
 *
 * NOTE: This is a simplified, transparent implementation for testing & backtest.
 */

/* ----------------------------
   Utility helpers
   ----------------------------*/
function last(arr, n = 1) { return arr.slice(-n)[0]; }
function sma(values, period) {
  if (values.length < period) return null;
  const s = values.slice(-period).reduce((a,b) => a+b, 0);
  return s / period;
}
function ema(values, period) {
  if (values.length < period) return null;
  const k = 2 / (period + 1);
  // seed with SMA
  let emaPrev = sma(values.slice(0, period), period);
  for (let i = period; i < values.length; i++) {
    emaPrev = values[i] * k + emaPrev * (1 - k);
  }
  return emaPrev;
}
function pctChange(a, b) { return (b - a) / a * 100; }

/* ----------------------------
   1D Trend detection (EMA slope + threshold)
   - Returns {trend: 'UP'|'DOWN'|'RANGE', confidence: 0-1}
   ----------------------------*/
function analyzeDailyTrend(klines1D) {
  // use close prices
  const closes = klines1D.map(k => k.c);
  const ema20 = ema(closes, 20);
  const ema50 = ema(closes, 50);
  if (ema20 == null || ema50 == null) return {trend: 'RANGE', confidence: 0};

  const diff = (ema20 - ema50) / ema50; // relative difference
  const absPct = Math.abs(diff);

  // threshold heuristics (tunable)
  if (diff > 0.003 && absPct > 0.003) { // ema20 above ema50
    const conf = Math.min(1, Math.abs(diff) / 0.02); // scaled confidence
    return {trend: 'UP', confidence: conf};
  } else if (diff < -0.003 && absPct > 0.003) {
    const conf = Math.min(1, Math.abs(diff) / 0.02);
    return {trend: 'DOWN', confidence: conf};
  } else {
    return {trend: 'RANGE', confidence: 0.2};
  }
}

/* ----------------------------
   Order block detection (4H)
   - Simple heuristic: region where price "dwells" & volume concentrated
   - Returns array of order blocks: {top, bottom, center, createdAtIdx, valid}
   ----------------------------*/
function detectOrderBlocks(klines4H, dwellBars = 3, maxAgeBars = 12 /*=2 days */) {
  const blocks = [];
  for (let i = dwellBars; i < klines4H.length; i++) {
    // examine window of dwellBars ending at i-1 (region where price stayed)
    const window = klines4H.slice(i - dwellBars, i);
    const high = Math.max(...window.map(k => k.h));
    const low = Math.min(...window.map(k => k.l));
    const range = high - low;
    // require small relative range and concentrated volume
    const avgVol = window.reduce((s, k) => s + k.v, 0) / dwellBars;
    const volConcentration = window[window.length - 1].v >= 0.7 * avgVol; // last bar has decent vol
    const priceStability = range <= (Math.min(...window.map(k => k.o, k.c)) * 0.006); // <=0.6% range

    if (priceStability && volConcentration) {
      blocks.push({
        top: high,
        bottom: low,
        center: (high + low) / 2,
        createdAtIdx: i - 1,
        valid: true
      });
    }
  }

  // filter by age (keep only <= maxAgeBars from latest)
  const latestIndex = klines4H.length - 1;
  return blocks.filter(b => (latestIndex - b.createdAtIdx) <= maxAgeBars);
}

/* ----------------------------
   Sweep detection relative to an order block
   - sweepDirection: 'below' | 'above' | null
   - returns {swept: bool, direction: 'below'|'above'|null, sweepLow/high}
   ----------------------------*/
function detectSweepAgainstBlock(klines, block) {
  // look at recent N candles for price wick penetration beyond block boundary and quick reversion
  const recent = klines.slice(-8); // check last 8 bars
  let swept = false, direction = null, sweepExtreme = null;
  for (let bar of recent) {
    if (bar.l < block.bottom && bar.c > block.bottom) { // wick below and close above => buy-side sweep
      swept = true; direction = 'below'; sweepExtreme = bar.l; break;
    }
    if (bar.h > block.top && bar.c < block.top) { // wick above and close below => sell-side sweep
      swept = true; direction = 'above'; sweepExtreme = bar.h; break;
    }
  }
  return {swept, direction, sweepExtreme};
}

/* ----------------------------
   Engulfing detection on 15M
   - simple bullish/bearish engulfing detection + strength (0-1)
   ----------------------------*/
function detectEngulfing(klines15M) {
  const len = klines15M.length;
  if (len < 2) return {type: null, strength: 0};
  const a = klines15M[len - 2], b = klines15M[len - 1];
  // bullish engulfing: b.c > b.o  & b.c > a.o  & b.o < a.c
  if (b.c > b.o && b.c > a.o && b.o < a.c) {
    // strength: how much bigger body is relative
    const bodyA = Math.abs(a.c - a.o), bodyB = Math.abs(b.c - b.o);
    const ratio = Math.min(1, bodyB / Math.max(1e-8, bodyA));
    // require volume expansion optionally
    return {type: 'BULL', strength: Math.min(1, ratio)};
  }
  // bearish engulfing
  if (b.c < b.o && b.c < a.o && b.o > a.c) {
    const bodyA = Math.abs(a.c - a.o), bodyB = Math.abs(b.c - b.o);
    const ratio = Math.min(1, bodyB / Math.max(1e-8, bodyA));
    return {type: 'BEAR', strength: Math.min(1, ratio)};
  }
  return {type: null, strength: 0};
}

/* ----------------------------
   Volume expansion check
   - last bar volume >= multiplier * avg of prior n bars
   ----------------------------*/
function detectVolumeExpansion(klines, lookback = 10, multiplier = 1.5) {
  if (klines.length < lookback + 1) return false;
  const vols = klines.slice(-(lookback + 1), -1).map(k => k.v);
  const avg = vols.reduce((a,b)=>a+b,0)/vols.length;
  const lastVol = last(klines).v;
  return lastVol >= avg * multiplier;
}

/* ----------------------------
   Stop loss and take profit calc
   - stopLoss: for BUY use sweep low or recent structure low; for SELL use sweep high / recent structure high
   - takeProfit: fixed RR ratio (e.g., 1:2)
   ----------------------------*/
function calcStops(signalType, entry, sweepExtreme, klinesHigherTF, rr = 2) {
  if (signalType === 'BUY') {
    // structural low: min low of last N bars on higher TF (e.g., 4H)
    const lookback = 6;
    const structLow = Math.min(...klinesHigherTF.slice(-lookback).map(k => k.l));
    const stop = sweepExtreme ? Math.min(sweepExtreme, structLow) : structLow;
    const tp = entry + (entry - stop) * rr;
    return {stopLoss: stop, takeProfit: tp};
  } else {
    const lookback = 6;
    const structHigh = Math.max(...klinesHigherTF.slice(-lookback).map(k => k.h));
    const stop = sweepExtreme ? Math.max(sweepExtreme, structHigh) : structHigh;
    const tp = entry - (stop - entry) * rr;
    return {stopLoss: stop, takeProfit: tp};
  }
}

/* ----------------------------
   Main decision function (structure-confirmation)
   ----------------------------*/
function generateSignal({klines1D, klines4H, klines15M}) {
  const reasons = [];
  // 1) Trend gate
  const trend = analyzeDailyTrend(klines1D);
  if (trend.trend === 'RANGE') {
    return {signal: null, reason: ['Daily trend not strong (RANGE)']};
  }
  const wantLong = trend.trend === 'UP';
  const wantShort = trend.trend === 'DOWN';
  reasons.push(`Daily trend: ${trend.trend} (conf ${trend.confidence.toFixed(2)})`);

  // 2) Order blocks (HTF)
  const blocks = detectOrderBlocks(klines4H);
  if (!blocks.length) return {signal: null, reason: ['No recent valid 4H order blocks']};
  // pick nearest block to price (center)
  const price = last(klines15M).c;
  blocks.sort((a,b)=> Math.abs(a.center - price) - Math.abs(b.center - price));
  const block = blocks[0];
  reasons.push(`Using order block centered at ${block.center.toFixed(2)}`);

  // 3) Sweep detection against that block on 4H recent
  const sweep = detectSweepAgainstBlock(klines15M.concat(klines4H.slice(-6)), block); // look at combined recent
  if (!sweep.swept) return {signal: null, reason: ['No sweep detected against selected order block']};
  reasons.push(`Sweep detected: ${sweep.direction} extreme=${sweep.sweepExtreme}`);

  // 4) Directional filter: only accept sweep that matches daily trend
  if (wantLong && sweep.direction !== 'below') return {signal: null, reason: ['Sweep direction not buy-side for UP trend']};
  if (wantShort && sweep.direction !== 'above') return {signal: null, reason: ['Sweep direction not sell-side for DOWN trend']};
  reasons.push('Sweep direction matches daily trend');

  // 5) LTF engulfing confirmation
  const engulf = detectEngulfing(klines15M);
  if (!engulf.type) return {signal: null, reason: ['No engulfing on 15M for confirmation']};
  if (wantLong && engulf.type !== 'BULL') return {signal: null, reason: ['Engulfing type mismatch for BUY']};
  if (wantShort && engulf.type !== 'BEAR') return {signal: null, reason: ['Engulfing type mismatch for SELL']};
  reasons.push(`Engulfing detected (${engulf.type}) strength=${engulf.strength.toFixed(2)}`);

  // 6) Volume expansion optional but recommended
  const volExp = detectVolumeExpansion(klines15M, 10, 1.3);
  if (!volExp) reasons.push('Volume expansion not detected on LTF (optional)');

  // 7) Final entry and stops
  const entry = last(klines15M).c;
  const stops = calcStops(wantLong ? 'BUY' : 'SELL', entry, sweep.sweepExtreme, klines4H);
  const signal = wantLong ? 'BUY' : 'SELL';
  reasons.push(`Entry @ ${entry.toFixed(6)} stop=${stops.stopLoss.toFixed(6)} tp=${stops.takeProfit.toFixed(6)}`);

  return {
    signal,
    entryLevel: entry,
    stopLoss: stops.stopLoss,
    takeProfit: stops.takeProfit,
    reason: reasons
  };
}

/* ----------------------------
   Example usage:
   (You should provide real klines arrays from your data source)
   ----------------------------*/
if (require && require.main === module) {
  // This block only runs when Node executed directly (for your local test).
  // Build small dummy candle arrays to test structure (in real use, replace with historical data).
  const now = Date.now();
  const mk = (o,h,l,c,v) => ({t: now, o,o,h,l,c,v});
  const klines1D = Array.from({length:80}, (_,i)=> mk(100+i, 100+i+2, 100+i-2, 100+i+1, 1000+i));
  const klines4H = Array.from({length:50}, (_,i)=> mk(100+i*0.5, 100+i*0.5+1, 100+i*0.5-1, 100+i*0.5+0.5, 500+i));
  const klines15M = Array.from({length:60}, (_,i)=> mk(110 + Math.sin(i/6)*2, 110 + Math.sin(i/6)*2 + 0.5, 110 + Math.sin(i/6)*2 - 0.5, 110 + Math.sin(i/6)*2 + 0.2, 200+i));

  const out = generateSignal({klines1D, klines4H, klines15M});
  console.log('Signal:', out);
}

module.exports = {
  analyzeDailyTrend,
  detectOrderBlocks,
  detectSweepAgainstBlock,
  detectEngulfing,
  detectVolumeExpansion,
  generateSignal
};

```

---

# é€æ­¥è¯´æ˜ï¼šæ¯æ®µä»£ç å¯¹åº”çš„ä¼˜åŒ–é€»è¾‘

1. `analyzeDailyTrend`ï¼ˆæ—¥çº¿ç­›é€‰ï¼‰
    - ä½¿ç”¨ EMA20 vs EMA50 çš„ç›¸å¯¹ä½ç½® + ç¼“å’Œé˜ˆå€¼åˆ¤å®šè¶‹åŠ¿ï¼ˆæ¯”å•çº¯â€œ20æ—¥æ¶¨å¹…â€æ›´å¹³æ»‘ï¼‰ã€‚
    - ä¼˜åŒ–ç†ç”±ï¼šé¿å…çŸ­æœŸæ³¢åŠ¨è¯¯åˆ¤æ—¥çº¿è¶‹åŠ¿ï¼Œä¸ºæ‰€æœ‰äº¤æ˜“æä¾›æ–¹å‘æ€§é—¨æ§›ï¼ˆå¿…é¡»æ¡ä»¶ï¼‰ã€‚
2. `detectOrderBlocks`ï¼ˆ4H è®¢å•å—æ£€æµ‹ï¼‰
    - é€šè¿‡â€œä»·æ ¼åœç•™ï¼ˆdwellï¼‰+ æˆäº¤é‡é›†ä¸­â€è¯†åˆ«è®¢å•å—ï¼Œå¹¶é™åˆ¶å¹´é¾„ï¼ˆé»˜è®¤ â‰¤12ä¸ª4Hæ¡ â‰ˆ 2å¤©ï¼‰ã€‚
    - ä¼˜åŒ–ç†ç”±ï¼šæ›´ä¸¥æ ¼åœ°æŒ‘å‡ºè¿‘æœŸä¸”å¯èƒ½ä»æœ‰æ•ˆçš„æœºæ„åŒºï¼Œè€Œä¸æ˜¯ç›²ç›®ä½¿ç”¨è€æ—§å—ã€‚
3. `detectSweepAgainstBlock`ï¼ˆæ‰«è¡æ–¹å‘åŒ–ï¼‰
    - æ£€æµ‹â€œwick ç©¿é€ + å½“æ ¹Kçº¿æ”¶å›â€çš„æ¨¡å¼ï¼Œå¹¶è¿”å›æ–¹å‘ï¼ˆbelow/aboveï¼‰ã€‚
    - ä¼˜åŒ–ç†ç”±ï¼šåªæ¥å—å’Œæ—¥çº¿è¶‹åŠ¿ä¸€è‡´çš„æ‰«è¡ï¼ˆä¸Šå‡è¶‹åŠ¿åªæ¥å—ä¸‹æ–¹æ‰«è¡ buy-sideï¼‰ï¼Œæ¶ˆé™¤æ–¹å‘é”™é…ã€‚
4. `detectEngulfing`ï¼ˆ15M åæ²¡ç¡®è®¤ï¼‰
    - ç®€åŒ–ä½†ä¿ç•™å¼ºåº¦è¯„ä¼°ï¼ˆä¸»ä½“æ¯”ç‡ï¼‰ï¼Œç”¨äº LTF æœ€ç»ˆç¡®è®¤ã€‚
    - ä¼˜åŒ–ç†ç”±ï¼šé¿å…å•æ ¹å°åæ²¡é€ æˆç«‹åˆ»å…¥åœºï¼Œè¦æ±‚åæ²¡åœ¨ç»“æ„ä¸æ–¹å‘ä¸ŠåŒ¹é…ã€‚
5. `detectVolumeExpansion`ï¼ˆé‡èƒ½æ”¾å¤§ï¼‰
    - å¯é€‰/åŠ å¼ºé¡¹ï¼šæœ€åç¡®è®¤é‡Œé¼“åŠ±æˆäº¤é‡æ”¾å¤§ï¼ˆé»˜è®¤ multiplier 1.3ï¼‰ã€‚
    - ä¼˜åŒ–ç†ç”±ï¼šæé«˜ä¿¡å·è´¨é‡ï¼Œå‡å°‘â€œæ— é‡å‡çªç ´â€ã€‚
6. `generateSignal`ï¼ˆé—¨æ§›å¼ã€é¡ºåºåŒ–é€»è¾‘ï¼‰
    - ä¸¥æ ¼æŒ‰é¡ºåºï¼šæ—¥çº¿è¶‹åŠ¿ â†’ æœ‰æ•ˆè®¢å•å— â†’ å­˜åœ¨æ‰«è¡ä¸”æ–¹å‘åŒ¹é… â†’ LTF åæ²¡ç¡®è®¤ â†’ å¯é€‰æˆäº¤é‡ã€‚
    - ä¼˜åŒ–ç†ç”±ï¼šæ›¿ä»£åŸå…ˆçš„çº¿æ€§åŠ æƒè¯„åˆ†ï¼ŒæŠŠ ICT çš„â€œç»“æ„é¡ºåºâ€ç¼–ç è¿›é€»è¾‘ï¼Œæ˜¾è‘—é™ä½é€†åŠ¿å…¥åœºã€‚
7. `calcStops`ï¼ˆç»“æ„åŒ–æ­¢æŸ/TPï¼‰
    - æ­¢æŸåŸºäºæ‰«è¡æå€¼æˆ–æœ€è¿‘çš„ç»“æ„ä½/é«˜ï¼ˆè€Œéå•çº¯ ATRï¼‰ï¼›TP æŒ‰å›ºå®šRRï¼ˆä¾‹å¦‚2ï¼‰ã€‚
    - ä¼˜åŒ–ç†ç”±ï¼šæ­¢æŸæ›´æ¥è¿‘å¸‚åœºç»“æ„ç‚¹ä½ï¼Œé¿å… ATR å¯¼è‡´çš„è¿‡å¤§æ­¢æŸå¸¦æ¥çš„é«˜é¢äºæŸã€‚

---

# è°ƒå‚å»ºè®®ï¼ˆåœ¨ä»£ç ä¸­å®¹æ˜“ä¿®æ”¹çš„åœ°æ–¹ï¼‰

- `dwellBars`ï¼ˆè®¢å•å—è¯†åˆ«çš„åœç•™Kçº¿æ•°ï¼‰ï¼Œ`maxAgeBars`ï¼ˆè®¢å•å—æœ€å¤§å¹´é¾„ï¼‰â€”â€”å†³å®šè®¢å•å—çš„ä¸¥æ ¼ç¨‹åº¦ã€‚
- EMA å‘¨æœŸï¼ˆ20/50â†’å¯æ”¹ä¸º 21/55 æˆ– 50/200 åšæ›´é•¿å‘¨æœŸè¶‹åŠ¿åˆ¤å®šï¼‰ã€‚
- `detectVolumeExpansion` çš„ `multiplier`ï¼šä¸¥æ ¼å€¼æé«˜å¯å‡å°‘å™ªå£°ã€‚
- `generateSignal` ä¸­å…³äºç­‰å¾… N æ ¹Kçº¿ç¡®è®¤ï¼ˆå¯åœ¨å‡½æ•°ä¸­åŠ å…¥ï¼‰é™ä½å‡ä¿¡å·ç‡ã€‚
- `rr`ï¼ˆé£é™©æŠ¥é…¬ï¼‰å¯è®¾ç½®ä¸º 1.5-2.5ï¼›ç”¨æ›´ä¿å®ˆçš„RRåœ¨èƒœç‡ä½æ—¶å¸®åŠ©é™ä½èµ„é‡‘å›æ’¤ã€‚

---

# å¦‚ä½•æŠŠå®ƒæ¥å…¥ä½ çš„å›æµ‹/å®ç›˜æµç¨‹ï¼ˆæ“ä½œæ­¥éª¤ï¼‰

1. ç”¨å†å²æ•°æ®åˆ†åˆ«æ„å»º `klines1D`, `klines4H`, `klines15M`ï¼ˆæŒ‰æ—¶é—´å¯¹é½ï¼‰ã€‚
2. åœ¨å›æµ‹å¾ªç¯æ¯æ ¹ 15M æ”¶ç›˜åè°ƒç”¨ `generateSignal()` è·å–æ˜¯å¦ä¸‹å•åŠæ­¢æŸ/ç›®æ ‡ã€‚
3. åœ¨å›æµ‹ä¸­è®°å½•ï¼šæ¯æ¬¡è§¦å‘å‰æ»¡è¶³å“ªäº›æ¡ä»¶ï¼ˆ`reason` å­—æ®µï¼‰ï¼Œä¾¿äºå› å­çº§åˆ«èƒœç‡åˆ†æã€‚
4. åšåˆ†ç›¸å›æµ‹ï¼ˆåªç­›ä¸Šå‡è¶‹åŠ¿æ ·æœ¬ã€éœ‡è¡ã€ä¸‹è·Œï¼‰æ¥å¯¹æ¯”ç­–ç•¥è¡¨ç°ã€‚
5. æ ¹æ®å›æµ‹ç»“æœå¾®è°ƒ `dwellBars`ã€volumeMultiplierã€RRã€ç¡®è®¤Kçº¿æ•°ç­‰å‚æ•°ã€‚

---

# å°ç»“ï¼ˆä¸€å¥è¯ï¼‰

è¿™å¥—å®ç°æŠŠâ€œæ—¥çº¿åšæ–¹å‘ã€4Hæ‰¾æœºæ„åŒºã€æ‰«è¡æ–¹å‘åŒ–ã€15Måæ²¡+é‡èƒ½åšæœ€ç»ˆç¡®è®¤ã€å‡ºå…¥åœºåŸºäºç»“æ„ç‚¹ä½â€çš„æ€è·¯ç¼–ç å‡ºæ¥ï¼Œç›®æ ‡æ˜¯**æå¤§å‡å°‘é€†åŠ¿å…¥åœºä¸è™šå‡ä¿¡å·**ï¼Œå¹¶æŠŠè¯„åˆ†å¼å™ªå£°æ›¿æ¢ä¸ºé¡ºåºåŒ–çš„é—¨æ§›å¼ç¡®è®¤ï¼Œä»è€Œæé«˜ä¸Šå‡è¶‹åŠ¿ä¸­çš„èƒœç‡å¹¶é™ä½å•ç¬”äºæŸã€‚

---

é€šè¿‡è°æ³¢å½¢æ€ï¼ˆCypher/Bat/Sharkï¼‰ç²¾å‡†åŒ– ICT å…¥åœºç¡®è®¤å±‚ï¼ˆ15Må±‚ï¼‰ï¼Œå½¢æˆã€Œç»“æ„åè½¬ + æ‰«è¡ç¡®è®¤ + è°æ³¢å…±æŒ¯ã€çš„å…¥åœºé€»è¾‘ï¼Œæ•´åˆå‡ºä¸€ä¸ª **å®Œæ•´ä¼˜åŒ–ç‰ˆ ICT + è°æ³¢å½¢æ€ï¼ˆCypher/Bat/Sharkï¼‰ç­–ç•¥**ï¼ŒåŒ…å«ä»¥ä¸‹åŠŸèƒ½ï¼š

* **å¤šæ—¶é—´æ¡†æ¶åˆ†æ**ï¼š1D æ—¥çº¿è¶‹åŠ¿ã€4H è®¢å•å—ã€15M æ‰«è¡ + åæ²¡
* **è°æ³¢å½¢æ€æ£€æµ‹**ï¼šCypher / Bat / Shark
* **15M å±‚æ‰«è¡æ£€æµ‹**ï¼ˆHTF/LTFï¼‰
* **ATR æ­¢æŸä¸æ­¢ç›ˆè®¡ç®—**
* **ç»¼åˆè¯„åˆ†ç”Ÿæˆäº¤æ˜“ä¿¡å·**ï¼š`BUY/SELL/WATCH/HOLD`
* **WebSocket å®æ—¶ K çº¿ç›‘æ§**

ä¸‹é¢æ˜¯å®Œæ•´ Node.js ç‰ˆæœ¬ç¤ºä¾‹ï¼š

```js
// npm install node-binance-api technicalindicators
const Binance = require('node-binance-api');
const ti = require('technicalindicators');
const binance = new Binance().options({
  APIKEY: 'YOUR_API_KEY',
  APISECRET: 'YOUR_API_SECRET'
});

// ---------- Helper Functions ---------- //

// è·å– K çº¿æ•°æ®
async function fetchKlines(symbol, interval, limit = 500) {
  const klines = await binance.futuresCandles(symbol, interval, { limit });
  return klines.map(k => ({
    open: parseFloat(k[1]),
    high: parseFloat(k[2]),
    low: parseFloat(k[3]),
    close: parseFloat(k[4]),
    volume: parseFloat(k[5]),
    time: k[0]
  }));
}

// ---------- ICT å› å­åˆ†æ ---------- //

function analyzeDailyTrend(klines1D) {
  const len = klines1D.length;
  if (len < 20) return { trend: 'NEUTRAL', score: 0 };
  const change = (klines1D[len - 1].close - klines1D[len - 20].close) / klines1D[len - 20].close;
  if (change > 0.03) return { trend: 'UP', score: 30 };
  if (change < -0.03) return { trend: 'DOWN', score: 30 };
  return { trend: 'NEUTRAL', score: 0 };
}

function analyzeOrderBlocks(klines4H) {
  const recent = klines4H.slice(-12);
  const high = Math.max(...recent.map(k => k.high));
  const low = Math.min(...recent.map(k => k.low));
  return { high, low, score: 20 };
}

function analyzeEngulfing(klines15M) {
  if (klines15M.length < 2) return { score: 0, type: 'NONE' };
  const last = klines15M[klines15M.length - 1];
  const prev = klines15M[klines15M.length - 2];
  if (last.close > last.open && prev.close < prev.open &&
      last.close > prev.open && last.open < prev.close) return { type: 'BULL', score: 25 };
  if (last.close < last.open && prev.close > prev.open &&
      last.close < prev.open && last.open > prev.close) return { type: 'BEAR', score: 25 };
  return { type: 'NONE', score: 0 };
}

function analyzeVolumeExpansion(klines15M) {
  const volumes = klines15M.map(k => k.volume);
  const avgVol = volumes.slice(-10).reduce((a, b) => a + b, 0) / 10;
  const lastVol = volumes[volumes.length - 1];
  return { score: lastVol > avgVol * 1.5 ? 5 : 0 };
}

// ---------- è°æ³¢å½¢æ€æ£€æµ‹ ---------- //

function detectHarmonicPattern(klines15M) {
  if (klines15M.length < 50) return { type: 'NONE', score: 0 };
  const X = klines15M[klines15M.length - 50].low;
  const A = klines15M[klines15M.length - 40].high;
  const B = klines15M[klines15M.length - 30].low;
  const C = klines15M[klines15M.length - 20].high;
  const D = klines15M[klines15M.length - 1].low;

  const calcFib = (start, end) => Math.abs((end - start) / start);

  const AB = calcFib(A, B);
  const BC = calcFib(B, C);
  const CD = calcFib(C, D);

  if (AB >= 0.382 && AB <= 0.618 && BC >= 1.13 && BC <= 1.414 && CD >= 0.786 && CD <= 0.886)
    return { type: 'CYPHER', score: 0.9 };
  if (AB >= 0.382 && AB <= 0.5 && BC >= 0.382 && BC <= 0.886 && CD >= 0.886 && CD <= 0.886)
    return { type: 'BAT', score: 0.8 };
  if (AB >= 0.618 && AB <= 1 && BC >= 1.13 && BC <= 1.618 && CD >= 0.886 && CD <= 1)
    return { type: 'SHARK', score: 0.85 };

  return { type: 'NONE', score: 0 };
}

// ---------- 15M æ‰«è¡æ£€æµ‹ ---------- //
function detectSweep(klines15M, orderBlock) {
  const last = klines15M[klines15M.length - 1];
  const sweepUp = last.high > orderBlock.high;
  const sweepDown = last.low < orderBlock.low;
  if (sweepUp || sweepDown) return { score: 15, direction: sweepUp ? 'UP' : 'DOWN' };
  return { score: 0, direction: 'NONE' };
}

// ---------- ATRæ­¢æŸ/æ­¢ç›ˆ ---------- //
function calculateATR(klines, period = 14) {
  const highs = klines.map(k => k.high);
  const lows = klines.map(k => k.low);
  const closes = klines.map(k => k.close);
  const atr = ti.ATR.calculate({ high: highs, low: lows, close: closes, period });
  return atr[atr.length - 1] || 0;
}

// ---------- ç»¼åˆè¯„åˆ† ---------- //
function computeICTScore(trend, orderBlock, engulfing, sweep, volume, harmonic) {
  return trend.score * 0.25 +
         orderBlock.score * 0.2 +
         engulfing.score * 0.15 +
         sweep.score * 0.15 +
         volume.score * 0.05 +
         harmonic.score * 0.2;
}

// ---------- ä¿¡å·åˆ¤å®š ---------- //
function generateSignal(totalScore, harmonicScore) {
  if (totalScore >= 45 && harmonicScore > 0.6) return 'BUY/SELL';
  if (totalScore >= 25) return 'WATCH';
  return 'HOLD';
}

// ---------- ä¸»ç­–ç•¥ ---------- //
async function runICTHarmonic(symbol) {
  const [klines1D, klines4H, klines15M] = await Promise.all([
    fetchKlines(symbol, '1d', 100),
    fetchKlines(symbol, '4h', 100),
    fetchKlines(symbol, '15m', 100)
  ]);

  const trend = analyzeDailyTrend(klines1D);
  const orderBlock = analyzeOrderBlocks(klines4H);
  const engulfing = analyzeEngulfing(klines15M);
  const sweep = detectSweep(klines15M, orderBlock);
  const volume = analyzeVolumeExpansion(klines15M);
  const harmonic = detectHarmonicPattern(klines15M);

  const totalScore = computeICTScore(trend, orderBlock, engulfing, sweep, volume, harmonic);
  const signal = generateSignal(totalScore, harmonic.score);
  const atr = calculateATR(klines15M);

  console.log(`[${symbol}] Signal: ${signal}`);
  console.log(`Total Score: ${totalScore.toFixed(2)}, Harmonic: ${harmonic.type}`);
  console.log(`ATR (for SL/TP): ${atr.toFixed(2)}, Sweep: ${sweep.direction}, Trend: ${trend.trend}`);
}

// ---------- WebSocket å®æ—¶ç›‘æ§ ---------- //
function subscribeSymbol(symbol) {
  binance.futuresMiniTickerStream(symbol, async ticker => {
    console.log(`å®æ—¶ä»·æ ¼: ${ticker.close}`);
    // æ¯5æ ¹15M Kçº¿è®¡ç®—ä¸€æ¬¡ä¿¡å·
  });

  // å¯å¢åŠ å®šæ—¶å™¨ï¼Œæ¯15åˆ†é’Ÿè°ƒç”¨ runICTHarmonic(symbol)
  setInterval(async () => await runICTHarmonic(symbol), 15 * 60 * 1000);
}

// ---------- å¯åŠ¨ ---------- //
(async () => {
  const symbol = 'BTCUSDT';
  subscribeSymbol(symbol);
})();
```

---

### âœ… ä¸»è¦ä¼˜åŒ–ç‚¹

1. **å¤šæ—¶é—´æ¡†æ¶ ICT**ï¼š1D / 4H / 15M åˆ†å±‚åˆ†æ
2. **è°æ³¢å½¢æ€å…±æŒ¯**ï¼šCypher/Bat/Shark ç²¾å‡†åŒ–å…¥åœº
3. **15M æ‰«è¡æ£€æµ‹**ï¼šå¿«é€Ÿçªç ´è®¢å•å—æ£€æµ‹
4. **ATR æ­¢æŸ/æ­¢ç›ˆ**ï¼šå¯ç›´æ¥è®¡ç®—é£é™©æ§åˆ¶
5. **WebSocket å®ç›˜ç›‘æ§**ï¼šå®æ—¶æ›´æ–°ä¿¡å·ï¼Œé€‚åˆè‡ªåŠ¨åŒ–äº¤æ˜“

# ç¬¬äºŒæ¬¡ä¼˜åŒ–

* `analyzeEngulfing` è¿”å›å¼ºåº¦ 0..1ï¼ˆæµ®ç‚¹ï¼‰
* `detectHarmonicPattern` è¿”å› `{ type, score(0..1), rmse }`ï¼ˆä»¥å½’ä¸€åŒ– RMSE æ˜ å°„åˆ° [0,1]ï¼‰
* `generateSignal` ä½¿ç”¨â€œé—¨æ§› + å®¹å¿/åˆ†çº§â€é€»è¾‘ï¼šä¾‹å¦‚ `OrderBlock && Sweep && (Engulfing >= 0.6 || Harmonic >= 0.6)` æ‰å…è®¸ç»§ç»­
* `waitForConfirmation`ï¼šè§¦å‘åç­‰å¾… 1..3 æ ¹ 15M æ”¶ç›˜ç¡®è®¤ï¼ˆå¯é…ç½®ï¼‰
* `calcStop`ï¼šè‡ªé€‚åº”æ­¢æŸå€æ•° `multiplier` = `maxMult - (maxMult - minMult) * confidence`ï¼ˆmin=1.5, max=2.5ï¼‰
* `positionSizing`ï¼šåŸºäº `totalScore` ä¸ä¼ å…¥çš„ `historicalWinRate` çš„çº¿æ€§æ˜ å°„
* `analyzeOrderBlocks` å¢å¼ºï¼šæ£€æµ‹è¢«æ‰«ååœ¨ 1-3 æ ¹ 4H æ”¶ç›˜å›å½’å¹¶æ”¶åœ¨å—ä¸Šæ–¹/å†…
* ç®€æ˜“ `telemetry.log`ï¼ˆå†™æ–‡ä»¶ï¼‰è®°å½•æ¯æ¬¡ä¿¡å·çš„å› å­æ•°æ®ï¼Œä¾¿äºåç»­ç¦»çº¿è®¡ç®—ç›¸å…³æ€§å’Œèƒœç‡

> æ³¨æ„ï¼šè°æ³¢é…å¯¹ä¸ RMSE çš„å®ç°é‡‡ç”¨äº†è¾ƒç¨³å¥ä½†ç®€åŒ–çš„â€œæ‘†ç‚¹ï¼ˆswingï¼‰æŠ½å– + æ®µæ¯”ç‡æ‹Ÿåˆâ€æ–¹æ³•ã€‚è°æ³¢è¯†åˆ«å¹¶ä¸æ˜¯ä¸¥æ ¼é‡‘èåº“çº§åˆ«çš„ç®—æ³•ï¼ˆçœŸå®ç”Ÿäº§å¯æ›¿æ¢ä¸ºæ›´æˆç†Ÿçš„è°æ³¢åº“ï¼‰ï¼Œä½†è¯¥å®ç°èƒ½è¾“å‡ºè¿ç»­çš„åŒ¹é…åº¦ç”¨äºç½®ä¿¡åº¦è®¡ç®—ä¸å›æµ‹ã€‚

---

## ä½¿ç”¨è¯´æ˜ï¼ˆæ¦‚è§ˆï¼‰

1. `npm init -y && npm i axios technicalindicators`
2. å°†ä»£ç ä¿å­˜ä¸º `ict_harmonic_improved.js`ï¼Œæ‰§è¡Œ `node ict_harmonic_improved.js BTCUSDT`ï¼ˆé»˜è®¤ symbol å¯åœ¨å‘½ä»¤è¡Œä¼ å…¥ï¼‰ã€‚
3. ä»£ç ä¼šæ‹‰å– 1D / 4H / 15M K çº¿å¹¶è¾“å‡ºä¿¡å·ç»“æœï¼›è‹¥è§¦å‘å…¥åœºï¼Œä¼šæ‰§è¡Œ `waitForConfirmation`ï¼ˆæœ€å¤šç­‰å¾… 3 æ ¹ 15M æ”¶ç›˜ï¼‰ï¼Œå¹¶è¾“å‡ºæœ€ç»ˆå»ºè®®ï¼ˆentry/stop/tp/sizeï¼‰ä»¥åŠ telemetry æ—¥å¿—å†™å…¥ `telemetry.log`ã€‚

---

## å®Œæ•´ä»£ç ï¼ˆNode.jsï¼‰

```javascript
/**
 * ict_harmonic_improved.js
 * - Uses Binance public REST to fetch klines
 * - Implements:
 *    - analyzeEngulfing -> strength 0..1
 *    - detectHarmonicPattern -> {type, score(0..1), rmse}
 *    - generateSignal -> gate + tolerance logic
 *    - waitForConfirmation -> wait 1..3 15m closes
 *    - calcStop -> adaptive ATR multiplier based on confidence
 *    - positionSizing -> basic linear mapping with historicalWinRate
 *    - enhanced order block validation (re-entry in 1-3 4H bars)
 *
 * Run: node ict_harmonic_improved.js BTCUSDT
 */

import axios from 'axios';
import fs from 'fs';
import { ATR } from 'technicalindicators';

const BINANCE = 'https://api.binance.com';
const TELEMETRY_FILE = 'telemetry.log';

// --- Helpers ---
const sleep = (ms) => new Promise(r => setTimeout(r, ms));
const nowStr = () => new Date().toISOString();

function last(arr, n = 1) { return arr[arr.length - n]; }
function sma(arr) { if (!arr.length) return 0; return arr.reduce((a,b)=>a+b,0)/arr.length; }
function clamp(v, a=0, b=1){ return Math.max(a, Math.min(b, v)); }

// --- Binance fetchers ---
async function fetchKlines(symbol, interval, limit = 500) {
  const url = `${BINANCE}/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const { data } = await axios.get(url);
  return data.map(k => ({
    t: k[0],
    o: +k[1],
    h: +k[2],
    l: +k[3],
    c: +k[4],
    v: +k[5]
  }));
}

// --- Indicator utilities ---
function computeATRFromKlines(klines, period = 14) {
  if (klines.length < period + 1) return null;
  const highs = klines.map(k=>k.h);
  const lows = klines.map(k=>k.l);
  const closes = klines.map(k=>k.c);
  const atrArr = ATR.calculate({high: highs, low: lows, close: closes, period});
  return atrArr[atrArr.length - 1] || null;
}

// --- 1) Engulfing detection returning strength 0..1 ---
function analyzeEngulfing(kl15m) {
  // strength based on body size ratio and total candle size
  if (kl15m.length < 2) return { type:'NONE', strength: 0 };
  const a = kl15m[kl15m.length - 2];
  const b = kl15m[kl15m.length - 1];

  const bodyA = Math.abs(a.c - a.o);
  const bodyB = Math.abs(b.c - b.o);
  const totalA = a.h - a.l;
  const totalB = b.h - b.l;

  // bullish engulfing
  if (b.c > b.o && a.c < a.o && b.c > a.o && b.o < a.c) {
    // strength: how much bigger bodyB relative to bodyA and relative to average size
    const ratio = bodyB / Math.max(1e-8, bodyA);
    const sizeFactor = bodyB / Math.max(1e-8, totalB);
    // normalize: ratio clipped to [1,5], map to [0.4,1]
    const rNorm = clamp((ratio - 1) / 4, 0, 1);
    const sNorm = clamp(sizeFactor, 0, 1);
    const strength = clamp(0.4 * rNorm + 0.6 * sNorm, 0, 1);
    return { type:'BULL', strength };
  }
  // bearish engulfing
  if (b.c < b.o && a.c > a.o && b.c < a.o && b.o > a.c) {
    const ratio = bodyB / Math.max(1e-8, bodyA);
    const sizeFactor = bodyB / Math.max(1e-8, totalB);
    const rNorm = clamp((ratio - 1) / 4, 0, 1);
    const sNorm = clamp(sizeFactor, 0, 1);
    const strength = clamp(0.4 * rNorm + 0.6 * sNorm, 0, 1);
    return { type:'BEAR', strength };
  }
  return { type:'NONE', strength: 0 };
}

// --- 2) Swing point extraction (simple pivot-based) ---
function extractSwingPoints(klines, lookback = 60) {
  // find local extremes in last lookback bars
  const data = klines.slice(-lookback);
  const highs = data.map(k => k.h);
  const lows = data.map(k => k.l);

  // find pivots: local max/min with window 3
  const pivots = [];
  for (let i = 2; i < data.length - 2; i++) {
    const win = data.slice(i-2, i+3);
    const center = data[i];
    if (center.h === Math.max(...win.map(x=>x.h))) {
      pivots.push({idx: i, type:'H', price: center.h, time: center.t});
    } else if (center.l === Math.min(...win.map(x=>x.l))) {
      pivots.push({idx: i, type:'L', price: center.l, time: center.t});
    }
  }
  return pivots;
}

// --- 3) Harmonic detection with normalized RMSE matching ---
function detectHarmonicPattern(kl15m) {
  // We try to find X-A-B-C-D sequence among recent pivots.
  const pivots = extractSwingPoints(kl15m, 120);
  // Need at least 5 pivots
  if (pivots.length < 5) return { type:'NONE', score:0, rmse: null };

  // Build candidate sequences (choose last 5 pivots in order)
  // naive approach: take last 5 pivots as X A B C D
  const last5 = pivots.slice(-5);
  // Ensure alternate H/L pattern; if not align by price direction
  const pts = last5.map(p => p.price);
  // convert to numeric segments: seg1 = |A-B| etc. We'll compute ratios relative to XA distance
  // For robustness, treat absolute moves
  const [X,A,B,C,D] = pts;
  const segXA = Math.abs(A - X) || 1e-8;
  const segAB = Math.abs(B - A) || 1e-8;
  const segBC = Math.abs(C - B) || 1e-8;
  const segCD = Math.abs(D - C) || 1e-8;

  // actual ratios (normalized by XA)
  const AB_r = segAB / segXA;
  const BC_r = segBC / segXA;
  const CD_r = segCD / segXA;

  // ideal ratio sets for each pattern (based on your ranges midpoint)
  const patterns = {
    CYPHER: { name:'CYPHER', ideal: [0.5, 1.25, 0.83] }, // AB~0.35-0.65 -> 0.5, BC~1.05-1.50->1.25, CD~0.75-0.95->0.83
    BAT: { name:'BAT', ideal: [0.45, 0.65, 0.875] },     // midpoints
    SHARK: { name:'SHARK', ideal: [1.35, 1.35, 0.95] }
  };

  const results = [];
  for (const k in patterns) {
    const ideal = patterns[k].ideal;
    // compute normalized RMSE between actual [AB_r, BC_r, CD_r] and ideal
    const errs = [
      (AB_r - ideal[0]) / (ideal[0] || 1),
      (BC_r - ideal[1]) / (ideal[1] || 1),
      (CD_r - ideal[2]) / (ideal[2] || 1)
    ];
    const mse = (errs[0]*errs[0] + errs[1]*errs[1] + errs[2]*errs[2]) / 3;
    const rmse = Math.sqrt(mse);
    // Map rmse to score: smaller rmse -> higher score
    // We need to normalize: typical rmse could be 0..~1 ; map with exp decay
    const score = clamp(Math.exp(-rmse * 2), 0, 1); // tuning: -rmse*2 yields smooth mapping
    results.push({ pattern: k, rmse, score });
  }

  // pick best match
  results.sort((a,b)=>b.score - a.score);
  const best = results[0];
  if (best.score < 0.15) return { type:'NONE', score:0, rmse: best.rmse }; // too low
  // For interpretability, if score in [0.6,0.85] => high confidence, >0.85 extreme
  return { type: patterns[best.pattern].name, score: best.score, rmse: best.rmse };
}

// --- 4) Sweep detection improved (15m wicks + quick reversion) ---
function detectSweep(kl15m, orderBlock) {
  // Look at last N bars
  const recent = kl15m.slice(-8);
  for (let i = recent.length - 1; i >= 0; i--) {
    const bar = recent[i];
    // buy-side sweep: wick below block.bottom but close above it
    if (bar.l < orderBlock.low && bar.c > orderBlock.low) {
      // check quick reversion: next few bars close above block low
      // but since we only have recent array, we check subsequent bars (if any)
      return { swept: true, direction: 'below', extreme: bar.l, confidence: 0.8 };
    }
    // sell-side sweep
    if (bar.h > orderBlock.high && bar.c < orderBlock.high) {
      return { swept: true, direction: 'above', extreme: bar.h, confidence: 0.8 };
    }
  }
  return { swept: false, direction: null, extreme: null, confidence: 0 };
}

// --- 5) Enhanced order block detection including "re-entry after sweep" ---
function analyzeOrderBlocks(kl4h) {
  // detect candidate blocks: use last 24 4H bars (approx 4 days)
  const recent = kl4h.slice(-24);
  // naive block detection: find price range where price stayed for >=3 bars
  const blocks = [];
  for (let i = 0; i < recent.length - 2; i++) {
    const window = recent.slice(i, i+3);
    const top = Math.max(...window.map(k=>k.h));
    const bot = Math.min(...window.map(k=>k.l));
    const range = top - bot;
    const avgPrice = sma(window.map(k=>k.c));
    if (range / avgPrice < 0.006) { // within 0.6% range
      // build block
      blocks.push({ top, bottom: bot, center: (top+bot)/2, createdIdx: i });
    }
  }
  if (!blocks.length) return { valid:false, block:null, score:0 };

  // choose the most recent block
  const block = blocks[blocks.length - 1];

  // check age: distance from latest
  const ageBars = recent.length - 1 - block.createdIdx;
  if (ageBars > 12) return { valid:false, block, score:0 }; // too old (>48h)

  // check if block was swept recently in the 4H window and re-entered
  // simplistic: look for any bar in last 12 bars that pierced block boundary then later closed inside/above
  let sweptIdx = -1;
  const last12 = kl4h.slice(-12);
  for (let i = 0; i < last12.length; i++) {
    if (last12[i].l < block.bottom && last12[i].c > block.bottom) sweptIdx = i;
    if (last12[i].h > block.top && last12[i].c < block.top) sweptIdx = i;
  }
  // if swept found, check re-entry: subsequent bars closing inside/above block for 1-3 bars
  let reentryConfirmed = false;
  if (sweptIdx >= 0) {
    const post = last12.slice(sweptIdx + 1, sweptIdx + 4);
    if (post.length) {
      const ok = post.some(b => b.c >= block.bottom && b.c <= block.top); // closes in block
      reentryConfirmed = ok;
    }
  } else {
    // if not swept, but price currently inside block, consider valid
    const latest = last(kl4h);
    reentryConfirmed = (latest.c >= block.bottom && latest.c <= block.top);
  }

  const score = reentryConfirmed ? 20 : 8; // penalize non-confirmed blocks
  return { valid: reentryConfirmed, block, score, sweptIdx };
}

// --- 6) Gate + tolerance signal generator + confirmation waiting ---
async function generateSignalWithConfirmation(symbol, opts = {}) {
  const {
    confirmationBars = 2, // 1..3
    minEngulfStrength = 0.6,
    minHarmonicScore = 0.6,
    accountUSD = 10000,
    historicalWinRate = 0.5
  } = opts;

  // fetch klines
  const [kl1d, kl4h, kl15m] = await Promise.all([
    fetchKlines(symbol, '1d', 60),
    fetchKlines(symbol, '4h', 60),
    fetchKlines(symbol, '15m', 200)
  ]);

  const trendChange = (last(kl1d).c - kl1d[kl1d.length - 20].c) / kl1d[kl1d.length - 20].c;
  const trend = trendChange > 0.02 ? 'UP' : trendChange < -0.02 ? 'DOWN' : 'RANGE';
  const trendScore = (trend === 'RANGE') ? 0 : 25;

  const orderBlockRes = analyzeOrderBlocks(kl4h);
  if (!orderBlockRes.block) {
    return { symbol, signal: 'HOLD', reason: 'no_order_block' };
  }
  // sweep detection on 15m
  const sweepRes = detectSweep(kl15m, { low: orderBlockRes.block.bottom, high: orderBlockRes.block.top });
  if (!sweepRes.swept) {
    return { symbol, signal: 'HOLD', reason: 'no_sweep' };
  }
  // engulfing
  const engulf = analyzeEngulfing(kl15m);
  // harmonic
  const harmonic = detectHarmonicPattern(kl15m);

  // Gate + tolerance logic:
  // require trend != RANGE and orderBlock valid and sweep
  // then allow if (engulf.strength >= minEngulfStrength OR harmonic.score >= minHarmonicScore)
  const gatePass = (trend !== 'RANGE') && orderBlockRes.valid && sweepRes.swept;
  const secondaryPass = (engulf.strength >= minEngulfStrength) || (harmonic.score >= minHarmonicScore);

  const reasons = [];
  reasons.push(`trend=${trend} change=${(trendChange*100).toFixed(2)}%`);
  reasons.push(`orderBlock.valid=${orderBlockRes.valid}`);
  reasons.push(`sweep.dir=${sweepRes.direction} conf=${sweepRes.confidence}`);
  reasons.push(`engulf=${engulf.type} strength=${engulf.strength.toFixed(2)}`);
  reasons.push(`harmonic=${harmonic.type} score=${harmonic.score.toFixed(3)} rmse=${harmonic.rmse?.toFixed(4)}`);

  if (!gatePass) {
    return { symbol, signal: 'HOLD', reason: 'gate_failed', reasons };
  }
  if (!secondaryPass) {
    // keep as WATCH if partially matched
    return { symbol, signal: 'WATCH', reason: 'secondary_failed', reasons, data:{engulf, harmonic} };
  }

  // passed initial gate -> wait for confirmation bars
  const confirmResult = await waitForConfirmation(symbol, confirmationBars, kl15m, orderBlockRes.block, { needDirection: sweepRes.direction });
  if (!confirmResult.confirmed) {
    // not confirmed -> WATCH
    return { symbol, signal: 'WATCH', reason: 'not_confirmed', reasons, confirmResult };
  }

  // compute totalScore combining factors but using continuous harmonic/engulfing scores
  // weights (tunable)
  const w = { trend:0.25, orderBlock:0.2, engulf:0.15, htfSweep:0.15, volume:0.05, harmonic:0.2 };
  const volScore = analyzeVolumeExpansion(kl15m).score/5; // 0..1
  const totalScore = Math.round( (w.trend*(trendScore/25) + w.orderBlock*(orderBlockRes.score/20) + w.engulf*engulf.strength + w.htfSweep*sweepRes.confidence + w.volume*volScore + w.harmonic*harmonic.score) * 100 );
  // confidence approx = harmonic.score*0.6 + engulf.strength*0.4 (tunable)
  const confidence = clamp(harmonic.score*0.6 + engulf.strength*0.4, 0, 1);

  // calculate ATR based stop
  const atr15 = computeATRFromKlines(kl15m, 14) || 0;
  const stopMult = calcStopMultiplier(confidence, { minMult:1.5, maxMult:2.5 });
  const stopDistance = atr15 * stopMult;

  // position sizing
  const positionUSD = positionSizing(totalScore, historicalWinRate, accountUSD);

  // assemble result
  const lastPrice = last(kl15m).c;
  const signalDir = (sweepRes.direction === 'below' && trend==='UP') ? 'BUY' : (sweepRes.direction === 'above' && trend==='DOWN') ? 'SELL' : (engulf.type==='BULL' ? 'BUY' : engulf.type==='BEAR' ? 'SELL' : 'BUY');

  // telemetry
  telemetryLog({ ts: nowStr(), symbol, totalScore, confidence, trend, orderBlock: orderBlockRes.block, sweepRes, engulf, harmonic, atr15, stopMult, positionUSD, signalDir });

  return {
    symbol,
    signal: signalDir,
    totalScore,
    confidence,
    entryPrice: lastPrice,
    stopLoss: signalDir==='BUY' ? lastPrice - stopDistance : lastPrice + stopDistance,
    takeProfit: signalDir==='BUY' ? lastPrice + stopDistance * 2 : lastPrice - stopDistance * 2,
    positionUSD,
    reasons
  };
}

// --- waitForConfirmation: polls for up to confirmationBars new 15m closes, checks that last close > (or <) certain threshold ---
// criteria: for BUY confirm last close > block.bottom and close above ema short or simply close above previous close and volume not dropping
async function waitForConfirmation(symbol, confirmationBars, kl15m_current, block, opts={needDirection:'below'}) {
  // We'll fetch new 15m candles up to confirmationBars times.
  let k15 = kl15m_current.slice(); // clone
  for (let i = 0; i < confirmationBars; i++) {
    // wait until next 15m close: compute time to next close based on last candle timestamp
    const lastTime = last(k15).t;
    const nextCloseTs = lastTime + 15*60*1000;
    const waitMs = Math.max(0, nextCloseTs - Date.now() + 1000); // +1s buffer
    if (waitMs > 0) await sleep(Math.min(waitMs, 60*1000)); // but cap sleep to 60s to avoid long blocking in testing
    // fetch latest small limit
    const fresh = await fetchKlines(symbol, '15m', 10);
    // find new candles not in k15 by timestamp
    const existingT = new Set(k15.map(x=>x.t));
    const newOnes = fresh.filter(x=>!existingT.has(x.t));
    if (newOnes.length) {
      k15 = k15.concat(newOnes);
    } else {
      // no new ones yet: proceed to next iteration (or break)
    }
    // evaluate confirmation: last candle closes inside/above block bottom (for buy), and volume >= previous average * 0.7
    const lastC = last(k15);
    const recentVolAvg = sma(k15.slice(-6).map(x=>x.v));
    const volOk = lastC.v >= recentVolAvg * 0.5; // allow soft threshold
    if (opts.needDirection === 'below') {
      if (lastC.c > block.bottom && volOk) return { confirmed:true, barsWaited: i+1 };
    } else if (opts.needDirection === 'above') {
      if (lastC.c < block.top && volOk) return { confirmed:true, barsWaited: i+1 };
    } else {
      // accept if price moves favorably relative to last close
      if (volOk) return { confirmed:true, barsWaited: i+1 };
    }
  }
  return { confirmed:false, barsWaited: confirmationBars };
}

// --- calcStopMultiplier based on confidence (0..1) ---
function calcStopMultiplier(confidence, opts={minMult:1.5, maxMult:2.5}) {
  const { minMult, maxMult } = opts;
  return maxMult - (maxMult - minMult) * confidence;
}

// --- position sizing (linear mapping using totalScore and historicalWinRate) ---
function positionSizing(totalScore, historicalWinRate=0.5, accountUSD=10000) {
  // base risk pct: 0.1% to 0.5% depending on totalScore (0..100) and historicalWinRate (0..1)
  const scoreFactor = totalScore / 100;
  const riskPct = 0.001 + (0.005 - 0.001) * (0.5 * scoreFactor + 0.5 * historicalWinRate); // 0.1%..0.5%
  const posUSD = accountUSD * riskPct;
  return Math.max(1, posUSD);
}

// --- simple telemetry logger (append to file) ---
function telemetryLog(obj) {
  const line = JSON.stringify(obj) + '\n';
  fs.appendFileSync(TELEMETRY_FILE, line);
}

// --- analyzeVolumeExpansion used earlier ---
function analyzeVolumeExpansion(kl15m) {
  const vols = kl15m.map(k=>k.v);
  if (vols.length < 10) return { score:0 };
  const avg = sma(vols.slice(-10));
  const lastVol = last(kl15m).v;
  return { score: lastVol > avg*1.5 ? 1 : 0 }; // normalized 0..1
}

// --- CLI runner ---
async function main() {
  const symbol = process.argv[2] || 'BTCUSDT';
  try {
    console.log(`[${nowStr()}] Running improved ICT+Harmonic for ${symbol} ...`);
    const res = await generateSignalWithConfirmation(symbol, { confirmationBars: 2, minEngulfStrength: 0.6, minHarmonicScore: 0.6, historicalWinRate: 0.52, accountUSD: 20000 });
    console.log(JSON.stringify(res, null, 2));
    console.log('Telemetry appended to', TELEMETRY_FILE);
  } catch (e) {
    console.error('Error:', e && e.message ? e.message : e);
  }
}

if (process.argv[1] && process.argv[1].endsWith('ict_harmonic_improved.js')) {
  main();
}

export {
  analyzeEngulfing,
  detectHarmonicPattern,
  generateSignalWithConfirmation,
  analyzeOrderBlocks,
  detectSweep,
  calcStopMultiplier,
  positionSizing,
  telemetryLog
};
```

---

## è®¾è®¡ä¸å®ç°è¯´æ˜ï¼ˆå…³é”®ç‚¹è§£è¯»ï¼‰

1. **é—¨æ§› + å®¹å¿ï¼ˆé—¨æ§›åˆ†çº§ï¼‰**

   * `generateSignalWithConfirmation` ä¸­å…ˆåš `gatePass`ï¼ˆè¶‹åŠ¿ + orderBlock + sweepï¼‰ï¼Œç„¶åç”¨ `secondaryPass` åˆ¤å®šåæ²¡å¼ºåº¦æˆ–è°æ³¢åŒ¹é…åº¦æ˜¯å¦æ»¡è¶³ä»»æ„ä¸€ä¸ªé˜ˆå€¼ï¼ˆ`minEngulfStrength` æˆ– `minHarmonicScore`ï¼‰ã€‚è¿™ä½“ç°äº†â€œäºŒé€‰ä¸€â€çš„å®¹å¿é€»è¾‘ï¼Œé¿å…å› å•ä¸€å› å­è½»å¾®æœªè¾¾è€Œå®Œå…¨ä¸¢å•ã€‚

2. **è°æ³¢åŒ¹é…åº¦ï¼ˆå›å½’+RMSEåˆ°scoreï¼‰**

   * `detectHarmonicPattern` æŠ½å–æ‘†ç‚¹å¹¶è®¡ç®—æ®µæ¯”ç‡ï¼Œè®¡ç®—è§„èŒƒåŒ– RMSEï¼Œå¹¶ç”¨ `score = exp(-rmse*2)` æ˜ å°„åˆ° [0,1]ã€‚ä¸å†äºŒå…ƒåˆ¤æ–­ï¼Œè€Œæ˜¯è¾“å‡ºè¿ç»­æ¦‚ç‡/ç½®ä¿¡åº¦ï¼Œç”¨äºåŠ æƒä¸ stop/size è®¡ç®—ã€‚

3. **ç­‰å¾… 1â€“3 æ ¹ 15M æ”¶ç›˜ç¡®è®¤**

   * `waitForConfirmation` ä¼šç­‰å¾…ä¸€å®šæ—¶é—´æ‹‰å–æœ€æ–° 15m K çº¿ï¼ˆæœ€å¤š `confirmationBars` æ ¹ï¼‰ï¼Œå¹¶ç”¨ç®€å•çš„æˆäº¤é‡/æ”¶ç›˜ä½ç½®åˆ¤å®šç¡®è®¤ã€‚ä½ å¯ä»¥æŠŠ `confirmationBars` è°ƒä¸º 1ã€2 æˆ– 3 å¹¶å›æµ‹æ¯”è¾ƒæ•ˆæœã€‚

4. **è‡ªé€‚åº”æ­¢æŸå€æ•°**

   * `calcStopMultiplier` æ˜ å°„ confidence åˆ° [minMult, maxMult]ï¼ˆé»˜è®¤ 1.5..2.5ï¼‰ã€‚`confidence` ç”±è°æ³¢ä¸åæ²¡å¼ºåº¦åŠ æƒå¾—åˆ°ï¼ˆåœ¨ `generateSignalWithConfirmation` ä¸­ç”¨ `confidence = harmonic*0.6 + engulf*0.4`ï¼‰ï¼Œæ˜ å°„åˆ°æ­¢æŸè·ç¦»ï¼Œä¿¡å¿ƒé«˜åˆ™æ­¢æŸæ›´ç´§ï¼ˆèŠ‚çœé£é™©ï¼‰ï¼Œä¿¡å¿ƒä½åˆ™æ­¢æ›´å®½ï¼ˆé˜²æ­¢å™ªå£°æ­¢æŸï¼‰ã€‚

5. **åˆ†å±‚ä»“ä½ç®¡ç†ï¼ˆåŸºç¡€ç‰ˆï¼‰**

   * `positionSizing` ä½¿ç”¨ `totalScore` ä¸ `historicalWinRate` åšçº¿æ€§ç»„åˆæ˜ å°„åˆ° `riskPct`ï¼ˆ0.1% åˆ° 0.5%ï¼‰ï¼Œè¿™èƒ½åœ¨ä¿¡å·æ›´å¼ºæˆ–å†å²èƒœç‡æ›´é«˜æ—¶æ”¾å¤§ä»“ä½ã€‚ä½ å¯ä»¥æ›¿æ¢ä¸ºæ›´å¤æ‚çš„è´å¶æ–¯æ›´æ–°æˆ–Kellyå…¬å¼å˜ä½“ã€‚

6. **è®¢å•å—å›å½’éªŒè¯**

   * `analyzeOrderBlocks` ç°åœ¨æ£€æµ‹åˆ°â€œè¢«æ‰«ååœ¨ 1-3 æ ¹ 4H K çº¿å›å½’å¹¶æ”¶åœ¨å—å†…/ä¸Šæ–¹â€æ‰è§†ä¸ºé«˜è´¨é‡è®¢å•å—ï¼ˆscore=20ï¼‰ï¼›å¦åˆ™å¾—åˆ†è¾ƒä½ï¼ˆ8ï¼‰ã€‚

7. **Telemetry**

   * æ¯æ¬¡å†³ç­–éƒ½ä¼šæŠŠå…³é”®å› å­ä¸ç»“æœå†™å…¥ `telemetry.log` ï¼ˆJSON æ¯è¡Œï¼‰ï¼Œæ–¹ä¾¿ä½ ç¦»çº¿åšå› å­èƒœç‡ã€ç›¸å…³æ€§å’Œæƒé‡å›å½’åˆ†æã€‚

è°ƒå‚å»ºè®®ï¼šminEngulfStrengthã€minHarmonicScoreã€confirmationBarsã€minMult/maxMult å››ä¸ªå‚æ•°åšç½‘æ ¼æœç´¢ï¼ˆç²—ç²’åº¦ï¼‰æ‰¾æœ€ç¨³å¥ç‚¹ã€‚

---