# è¶‹åŠ¿äº¤æ˜“ç­–ç•¥-V3

# **1. æ—¶é—´æ¡†æ¶è®¾è®¡**

- è¶‹åŠ¿è¿‡æ»¤ï¼ˆ4Hï¼‰ â†’ åˆ¤æ–­å¤§æ–¹å‘ï¼ˆå¤šå¤´è¶‹åŠ¿å¸‚/ç©ºå¤´è¶‹åŠ¿å¸‚/éœ‡è¡å¸‚ï¼‰ã€‚
- è¶‹åŠ¿ç¡®è®¤ï¼ˆ1Hï¼‰ â†’ å¤šå› å­æ‰“åˆ†æœºåˆ¶ï¼ŒéªŒè¯è¶‹åŠ¿æœ‰æ•ˆæ€§ã€‚
- å…¥åœºæ‰§è¡Œï¼ˆ15mï¼‰ â†’ ç²¾ç¡®æ‹©æ—¶ï¼Œè®¾ç½®æ­¢ç›ˆæ­¢æŸã€‚

# **2. ç­–ç•¥é€»è¾‘åˆ†å±‚**

**ğŸ”¹ 2.1 4H è¶‹åŠ¿è¿‡æ»¤**

- å¤šå¤´è¶‹åŠ¿æ¡ä»¶ï¼š
    - MA20 > MA50 > MA200
    - æ”¶ç›˜ä»· > MA20
- ç©ºå¤´è¶‹åŠ¿æ¡ä»¶ï¼š
    - MA20 < MA50 < MA200
    - æ”¶ç›˜ä»· < MA20
- é¢å¤–è¿‡æ»¤ï¼šADX(14) > 20 ä¸”å¸ƒæ—å¸¦å¸¦å®½æ‰©å¼ ï¼ˆè¶‹åŠ¿å¼ºåº¦ç¡®è®¤ï¼‰ã€‚
- è¿ç»­ç¡®è®¤æœºåˆ¶ï¼š
    - è‡³å°‘ 2 æ ¹ 4H K çº¿ï¼ˆâ‰ˆ8 å°æ—¶ï¼‰æ»¡è¶³è¶‹åŠ¿å¸‚æ¡ä»¶ â†’ åˆ¤å®šè¶‹åŠ¿å¸‚æˆç«‹ã€‚
    - å¦åˆ™åˆ¤å®šä¸ºéœ‡è¡å¸‚ã€‚
- è¾“å‡ºï¼štrend4h = "å¤šå¤´è¶‹åŠ¿" | "ç©ºå¤´è¶‹åŠ¿" | "éœ‡è¡å¸‚"

**ğŸ”¹ 2.2 å¤šå¤´è¶‹åŠ¿ï½œç©ºå¤´è¶‹åŠ¿ ç»Ÿç§°ä¸ºè¶‹åŠ¿å¸‚ï¼Œè¿˜éœ€è¦1Hå¤šå› å­æ‰“åˆ†ç¡®è®¤å’Œ15åˆ†é’Ÿå…¥åœºæ‰§è¡Œç¡®è®¤æ­¢ç›ˆæ­¢æŸåæ‰ä¼šå¼€å§‹äº¤æ˜“ã€‚**

- **2.2.1 1H å¤šå› å­æ‰“åˆ†ç¡®è®¤ï¼ˆscore â‰¥3 æ‰æœ‰æ•ˆï¼‰**
    1. VWAP æ–¹å‘ä¸€è‡´ï¼ˆå¿…é¡»æ»¡è¶³ï¼‰
        - å¤šå¤´ï¼šæ”¶ç›˜ä»· > VWAP
        - ç©ºå¤´ï¼šæ”¶ç›˜ä»· < VWAP
    2. çªç ´ç¡®è®¤
        - å¤šå¤´ï¼šæ”¶ç›˜ä»·çªç ´æœ€è¿‘ 20 æ ¹ 4H Kçº¿é«˜ç‚¹
        - ç©ºå¤´ï¼šæ”¶ç›˜ä»·è·Œç ´æœ€è¿‘ 20 æ ¹ 4H Kçº¿ä½ç‚¹
    3. æˆäº¤é‡åŒç¡®è®¤
        - 15m æˆäº¤é‡ â‰¥ 1.5 Ã— 20æœŸå‡é‡
        - 1h æˆäº¤é‡ â‰¥ 1.2 Ã— 20æœŸå‡é‡
    4. OIï¼ˆæœªå¹³ä»“åˆçº¦é‡ï¼‰å˜åŒ–
        - å¤šå¤´ï¼š6h OI â‰¥ +2%
        - ç©ºå¤´ï¼š6h OI â‰¤ -3%
    5. èµ„é‡‘è´¹ç‡
        - 0.05% â‰¤ Funding Rate â‰¤ +0.05%
    6. Delta/ä¹°å–ç›˜ä¸å¹³è¡¡
        - å¤šå¤´ï¼šä¸»åŠ¨ä¹°ç›˜ â‰¥ å–ç›˜ Ã— 1.2
        - ç©ºå¤´ï¼šä¸»åŠ¨å–ç›˜ â‰¥ ä¹°ç›˜ Ã— 1.2

è¶‹åŠ¿å¸‚å’Œéœ‡è¡å¸‚çš„åˆ¤æ–­é€»è¾‘å®ç°ï¼š

```jsx
/**
 * detectTrendMarket.js
 * å®Œæ•´è¶‹åŠ¿å¸‚ + éœ‡è¡å¸‚åˆ¤æ–­ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 * è¾“å…¥ï¼š
 *  - candles4h: 4H Kçº¿æ•°ç»„ [{high, low, close, volume}]
 *  - candles1h: 1H Kçº¿æ•°ç»„ [{high, low, close, volume, vwap, oiChange, fundingRate, delta}]
 *  - options: 1H å¤šå› å­é˜ˆå€¼ {volMultiplier, oiChange, fundingRateMax, deltaThreshold}
 * è¾“å‡ºï¼š
 *  - { trend4h: "LONG"|"SHORT"|"NONE", score1h: number, entryAllowed: true|false, isRanging: true|false }
 */

function calculateMA(candles, period = 20) {
  return candles.map((c, i) => {
    if (i < period - 1) return null;
    const sum = candles.slice(i - period + 1, i + 1).reduce((acc, x) => acc + x.close, 0);
    return sum / period;
  });
}

function calculateADX(candles, period = 14) {
  if (!candles || candles.length < period + 1) return null;

  const TR = [], DMplus = [], DMminus = [];
  for (let i = 1; i < candles.length; i++) {
    const high = candles[i].high, low = candles[i].low, closePrev = candles[i-1].close;
    const highPrev = candles[i-1].high, lowPrev = candles[i-1].low;

    const tr = Math.max(high - low, Math.abs(high - closePrev), Math.abs(low - closePrev));
    TR.push(tr);

    const upMove = high - highPrev;
    const downMove = lowPrev - low;

    DMplus.push(upMove > downMove && upMove > 0 ? upMove : 0);
    DMminus.push(downMove > upMove && downMove > 0 ? downMove : 0);
  }

  function smooth(arr) {
    const smoothed = [];
    let sum = arr.slice(0, period).reduce((a,b)=>a+b,0);
    smoothed[period-1] = sum;
    for(let i=period;i<arr.length;i++){
      sum = smoothed[i-1] - smoothed[i-1]/period + arr[i];
      smoothed[i] = sum;
    }
    return smoothed;
  }

  const smTR = smooth(TR), smDMplus = smooth(DMplus), smDMminus = smooth(DMminus);
  const DIplus = smDMplus.map((v,i)=> i>=period-1 ? 100*v/smTR[i]: null);
  const DIminus = smDMminus.map((v,i)=> i>=period-1 ? 100*v/smTR[i]: null);
  const DX = DIplus.map((v,i)=> i<period-1? null : 100*Math.abs(DIplus[i]-DIminus[i])/(DIplus[i]+DIminus[i]));
  const ADX = [];
  let sumDX = DX.slice(period-1, period-1+period).reduce((a,b)=>a+b,0);
  ADX[period*2-2] = sumDX/period;
  for(let i=period*2-1;i<DX.length;i++){
    ADX[i] = (ADX[i-1]*(period-1)+DX[i])/period;
  }
  const last = ADX.length-1;
  return { ADX: ADX[last]||null, DIplus: DIplus[last]||null, DIminus: DIminus[last]||null };
}

/**
 * è®¡ç®—1Hå¤šå› å­æ‰“åˆ†ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 * VWAPæ–¹å‘å¿…é¡»ä¸€è‡´ï¼Œå¦åˆ™è¿”å›0
 * å…¶ä»–å› å­åªåŠ åˆ†ï¼Œä¸å‡åˆ†
 */
function score1h(candles1h, trend4h, options){
  if(candles1h.length<20) return 0;
  const last = candles1h[candles1h.length-1];

  // å¼ºåˆ¶VWAPæ–¹å‘ä¸€è‡´
  if(trend4h==="LONG" && last.close <= last.vwap) return 0;
  if(trend4h==="SHORT" && last.close >= last.vwap) return 0;

  let score = 0;

  // æœ€è¿‘20Kçº¿çªç ´é«˜ä½ç‚¹
  const highs = candles1h.slice(-20).map(c=>c.high);
  const lows = candles1h.slice(-20).map(c=>c.low);
  if(trend4h==="LONG" && last.close>Math.max(...highs)) score+=1;
  if(trend4h==="SHORT" && last.close<Math.min(...lows)) score+=1;

  // æˆäº¤é‡
  const avgVol = candles1h.slice(-20).reduce((a,c)=>a+c.volume,0)/20;
  if(last.volume>=avgVol*options.volMultiplier) score+=1;

  // OIå˜åŒ–
  if(trend4h==="LONG" && last.oiChange>=options.oiChange) score+=1;
  if(trend4h==="SHORT" && last.oiChange<=-options.oiChange) score+=1;

  // èµ„é‡‘è´¹ç‡
  if(Math.abs(last.fundingRate)<=options.fundingRateMax) score+=1;

  // Delta
  if(Math.abs(last.delta)>=options.deltaThreshold) score+=1;

  return score;
}

/**
 * detectTrendMarket - å®Œæ•´è¶‹åŠ¿å¸‚ + éœ‡è¡å¸‚åˆ¤æ–­ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
 */
function detectTrendMarket(candles4h, candles1h, options){
  const ma20 = calculateMA(candles4h,20);
  const ma50 = calculateMA(candles4h,50);
  const ma200 = calculateMA(candles4h,200);
  const close4h = candles4h[candles4h.length-1].close;

  const isLongMA = ma20[ma20.length-1]>ma50[ma50.length-1] && ma50[ma50.length-1]>ma200[ma200.length-1] && close4h>ma20[ma20.length-1];
  const isShortMA = ma20[ma20.length-1]<ma50[ma50.length-1] && ma50[ma50.length-1]<ma200[ma200.length-1] && close4h<ma20[ma20.length-1];

  const {ADX, DIplus, DIminus} = calculateADX(candles4h,14);
  const adxLong = ADX>20 && DIplus>DIminus;
  const adxShort = ADX>20 && DIminus>DIplus;

  let trend4h = "NONE";
  if(isLongMA && adxLong) trend4h="LONG";
  if(isShortMA && adxShort) trend4h="SHORT";

  // è®¡ç®—1Hæ‰“åˆ†
  const score = score1h(candles1h, trend4h, options);

  // entryAllowedï¼šè¶‹åŠ¿å¸‚å…è®¸å…¥åœº
  let entryAllowed = false;
  if(trend4h==="LONG" && score>0) entryAllowed = true;
  if(trend4h==="SHORT" && score>0) entryAllowed = true;

  // isRangingï¼šéœ‡è¡å¸‚åˆ¤å®š
  let isRanging = false;
  if(trend4h==="NONE") isRanging = true; // 4Hæ— è¶‹åŠ¿
  else if(score===0) isRanging = true; // VWAPæ–¹å‘ä¸ç¬¦æˆ–çŸ­æœŸä¿¡å·ä¸æ”¯æŒå…¥åœº

  return { trend4h, score1h: score, entryAllowed, isRanging };
}

// Node.js å¯¼å‡º
if(typeof module!=="undefined" && module.exports){
  module.exports = { detectTrendMarket, calculateMA, calculateADX, score1h };
}
```

- **2.2.2 15m å…¥åœºæ‰§è¡Œé€»è¾‘**
    1. å¤šå¤´æ¨¡å¼ (long)
        1. ä»·æ ¼å›è¸© EMA20/50 æˆ–å‰é«˜ â†’ æ”¯æ’‘æœ‰æ•ˆ
        2. æˆäº¤é‡ç¼©å°ï¼Œæœªç ´ä½
        3. çªç ´ä¸Šä¸€æ ¹ setup candle é«˜ç‚¹ â†’ å…¥åœº
        4. æ­¢æŸï¼šmin(setup candle ä½ç‚¹, æ”¶ç›˜ä»· - 1.2 Ã— ATR(14))
        5. æ­¢ç›ˆï¼šâ‰¥ 2R
    2. ç©ºå¤´æ¨¡å¼ (short)
        1. ä»·æ ¼åå¼¹è‡³ EMA20/50 æˆ–å‰ä½ â†’ é˜»åŠ›æœ‰æ•ˆ
        2. æˆäº¤é‡ç¼©å°ï¼Œæœªçªç ´
        3. è·Œç ´ä¸Šä¸€æ ¹ setup candle ä½ç‚¹ â†’ å…¥åœº
        4. æ­¢æŸï¼šmax(setup candle é«˜ç‚¹, æ”¶ç›˜ä»· + 1.2 Ã— ATR(14))
        5. æ­¢ç›ˆï¼šâ‰¥ 2R

æ­¢æŸé€»è¾‘ä»£ç å®ç°ï¼š

```jsx
/**
 * å‡ºåœºåˆ¤æ–­ï¼ˆåŒ…å«æ—¶é—´æ­¢æŸï¼‰
 * @param {Object} params
 * @param {string} params.position - "long" æˆ– "short"
 * @param {number} params.entryPrice - å…¥åœºä»·æ ¼
 * @param {Object} params.setupCandle - å…¥åœºKçº¿ { high, low, close }
 * @param {number} params.atr14 - ATR(14) æœ€æ–°å€¼
 * @param {number} params.currentPrice - å½“å‰ä»·æ ¼
 * @param {number} params.score1h - 1H å¤šå› å­æ‰“åˆ†
 * @param {string} params.trend4h - å½“å‰4Hè¶‹åŠ¿ ("å¤šå¤´" | "ç©ºå¤´" | "éœ‡è¡")
 * @param {number} params.deltaBuy - å½“å‰ä¸»åŠ¨ä¹°ç›˜é‡
 * @param {number} params.deltaSell - å½“å‰ä¸»åŠ¨å–ç›˜é‡
 * @param {number} params.ema20 - EMA20 å½“å‰å€¼
 * @param {number} params.ema50 - EMA50 å½“å‰å€¼
 * @param {number} params.prevHigh - è¿‘æœŸå‰é«˜
 * @param {number} params.prevLow - è¿‘æœŸå‰ä½
 * @param {number} params.timeInPosition - å·²æŒä»“æ—¶é—´ï¼Œå•ä½ï¼š15m Kçº¿æ•°
 * @param {number} params.maxTimeInPosition - æœ€å¤§å…è®¸æŒä»“æ—¶é—´ï¼Œå•ä½ï¼š15m Kçº¿æ•°
 * @returns {Object} { exit: boolean, reason: string, exitPrice: number }
 */
function checkExit(params) {
  const {
    position,
    entryPrice,
    setupCandle,
    atr14,
    currentPrice,
    score1h,
    trend4h,
    deltaBuy,
    deltaSell,
    ema20,
    ema50,
    prevHigh,
    prevLow,
    timeInPosition,
    maxTimeInPosition
  } = params;

  let stopLoss, takeProfit;

  // æ­¢æŸè®¡ç®—
  if (position === "long") {
    stopLoss = Math.min(setupCandle.low, entryPrice - 1.2 * atr14);
    takeProfit = entryPrice + 2 * (entryPrice - stopLoss);
  } else {
    stopLoss = Math.max(setupCandle.high, entryPrice + 1.2 * atr14);
    takeProfit = entryPrice - 2 * (stopLoss - entryPrice);
  }

  // 1ï¸âƒ£ æ­¢æŸè§¦å‘
  if ((position === "long" && currentPrice <= stopLoss) ||
      (position === "short" && currentPrice >= stopLoss)) {
    return { exit: true, reason: "æ­¢æŸè§¦å‘", exitPrice: stopLoss };
  }

  // 2ï¸âƒ£ æ­¢ç›ˆè§¦å‘
  if ((position === "long" && currentPrice >= takeProfit) ||
      (position === "short" && currentPrice <= takeProfit)) {
    return { exit: true, reason: "æ­¢ç›ˆè§¦å‘", exitPrice: takeProfit };
  }

  // 3ï¸âƒ£ è¶‹åŠ¿åè½¬
  if ((position === "long" && (trend4h !== "å¤šå¤´" || score1h < 3)) ||
      (position === "short" && (trend4h !== "ç©ºå¤´" || score1h < 3))) {
    return { exit: true, reason: "è¶‹åŠ¿æˆ–å¤šå› å­åè½¬", exitPrice: currentPrice };
  }

  // 4ï¸âƒ£ Delta / ä¹°å–ç›˜å‡å¼±
  if ((position === "long" && deltaBuy / (deltaSell || 1) < 1.1) ||
      (position === "short" && deltaSell / (deltaBuy || 1) < 1.1)) {
    return { exit: true, reason: "Delta / ä¸»åŠ¨ä¹°å–ç›˜å‡å¼±", exitPrice: currentPrice };
  }

  // 5ï¸âƒ£ ä»·æ ¼è·Œç ´å…³é”®æ”¯æ’‘ / çªç ´å…³é”®é˜»åŠ›
  if ((position === "long" && (currentPrice < ema20 || currentPrice < ema50 || currentPrice < prevLow)) ||
      (position === "short" && (currentPrice > ema20 || currentPrice > ema50 || currentPrice > prevHigh))) {
    return { exit: true, reason: "è·Œç ´æ”¯æ’‘æˆ–çªç ´é˜»åŠ›", exitPrice: currentPrice };
  }

  // 6ï¸âƒ£ æ—¶é—´æ­¢æŸ
  if (timeInPosition >= maxTimeInPosition) {
    return { exit: true, reason: "è¶…æ—¶æ­¢æŸ", exitPrice: currentPrice };
  }

  // å¦åˆ™ç»§ç»­æŒä»“
  return { exit: false, reason: "", exitPrice: null };
}

// ==== ä½¿ç”¨ç¤ºä¾‹ ====
const exitSignal = checkExit({
  position: "long",
  entryPrice: 100,
  setupCandle: { high: 102, low: 99, close: 101 },
  atr14: 1.5,
  currentPrice: 101.2,
  score1h: 4,
  trend4h: "å¤šå¤´",
  deltaBuy: 1200,
  deltaSell: 900,
  ema20: 101.5,
  ema50: 100.8,
  prevHigh: 103,
  prevLow: 99.5,
  timeInPosition: 13,   // å·²æŒä»“13æ ¹15m Kçº¿
  maxTimeInPosition: 12 // æœ€å¤§å…è®¸12æ ¹15m Kçº¿
});

console.log(exitSignal);
/**
 è¾“å‡ºç¤ºä¾‹:
 {
   exit: true,
   reason: "è¶…æ—¶æ­¢æŸ",
   exitPrice: 101.2
 }
*/
```

å¤šå› å­æ‰“åˆ†é€»è¾‘å®ç°ï¼š

```jsx
/**
 * 4å°æ—¶çº§åˆ«å¤šå› å­æ‰“åˆ†ç³»ç»Ÿ
 * 
 * VWAP å¿…é¡»æ–¹å‘ä¸€è‡´ï¼Œå¦åˆ™ç›´æ¥è¿”å› 0 åˆ†
 * å…¶ä»–å› å­æ¯æ»¡è¶³ä¸€ä¸ª +1
 * 
 * @param {Object} params
 * @param {string} params.trend4h - 4å°æ—¶è¶‹åŠ¿ ("å¤šå¤´" | "ç©ºå¤´" | "éœ‡è¡")
 * @param {number} params.close - æœ€æ–°æ”¶ç›˜ä»·
 * @param {number} params.vwap - å½“å‰ VWAP å€¼
 * @param {number} params.breakoutLevel - å…³é”®çªç ´ä»·ä½ï¼ˆæ¯”å¦‚20æ ¹4Hé«˜ç‚¹/ä½ç‚¹ï¼‰
 * @param {number} params.volume15m - æœ€æ–°15mæˆäº¤é‡
 * @param {number} params.avgVolume15m - è¿‡å»20æœŸ15må‡é‡
 * @param {number} params.volume1h - æœ€æ–°1hæˆäº¤é‡
 * @param {number} params.avgVolume1h - è¿‡å»20æœŸ1hå‡é‡
 * @param {number} params.oiChange6h - æœ€è¿‘6å°æ—¶OIå˜åŠ¨ç™¾åˆ†æ¯” (å¦‚ 0.025 = +2.5%)
 * @param {number} params.fundingRate - å½“å‰èµ„é‡‘è´¹ç‡ (æ¯8h)
 * @param {number} params.deltaBuy - ä¸»åŠ¨ä¹°ç›˜æˆäº¤é‡
 * @param {number} params.deltaSell - ä¸»åŠ¨å–ç›˜æˆäº¤é‡
 * 
 * @returns {Object} { score, allowLong, allowShort }
 */
function scoreFactors4h({
  trend4h,
  close,
  vwap,
  breakoutLevel,
  volume15m,
  avgVolume15m,
  volume1h,
  avgVolume1h,
  oiChange6h,
  fundingRate,
  deltaBuy,
  deltaSell
}) {
  let score = 0;
  let allowLong = false;
  let allowShort = false;

  // 1. VWAP å¿…é¡»æ–¹å‘ä¸€è‡´
  if (trend4h === "å¤šå¤´" && close <= vwap) return { score: 0, allowLong, allowShort };
  if (trend4h === "ç©ºå¤´" && close >= vwap) return { score: 0, allowLong, allowShort };

  // 2. çªç ´æ¡ä»¶ (4hå…³é”®ä½çªç ´)
  if (trend4h === "å¤šå¤´" && close > breakoutLevel) score++;
  if (trend4h === "ç©ºå¤´" && close < breakoutLevel) score++;

  // 3. æˆäº¤é‡åŒç¡®è®¤ (15m + 1h)
  if (volume15m >= 1.5 * avgVolume15m && volume1h >= 1.2 * avgVolume1h) {
    score++;
  }

  // 4. OIå˜åŒ–
  if (trend4h === "å¤šå¤´" && oiChange6h >= 0.02) score++; // â‰¥+2%
  if (trend4h === "ç©ºå¤´" && oiChange6h <= -0.03) score++; // â‰¤-3%

  // 5. èµ„é‡‘è´¹ç‡åˆç†
  if (fundingRate >= -0.0005 && fundingRate <= 0.0005) {
    score++;
  }

  // 6. Delta/ä¸»åŠ¨ä¹°å–ç›˜ä¸å¹³è¡¡
  if (trend4h === "å¤šå¤´" && deltaBuy >= 1.2 * deltaSell) score++;
  if (trend4h === "ç©ºå¤´" && deltaSell >= 1.2 * deltaBuy) score++;

  // åˆ¤æ–­æ˜¯å¦å…è®¸å¼€ä»“
  if (trend4h === "å¤šå¤´" && score >= 3) allowLong = true;
  if (trend4h === "ç©ºå¤´" && score >= 3) allowShort = true;

  return { score, allowLong, allowShort };
}

// ==== ç¤ºä¾‹è°ƒç”¨ ====
const result = scoreFactors4h({
  trend4h: "å¤šå¤´",
  close: 102,
  vwap: 101,
  breakoutLevel: 100,
  volume15m: 1500,
  avgVolume15m: 900,
  volume1h: 6000,
  avgVolume1h: 4500,
  oiChange6h: 0.025, // +2.5%
  fundingRate: 0.0002, // 0.02%/8h
  deltaBuy: 1200,
  deltaSell: 800
});

console.log(result);
/**
 è¾“å‡ºç¤ºä¾‹:
 {
   score: 5,
   allowLong: true,
   allowShort: false
 }
 */
```

delta é€»è¾‘å®ç°

```jsx
// deltaOrderflow.js
const WebSocket = require("ws");

class DeltaOrderflow {
  constructor(symbol = "btcusdt") {
    this.symbol = symbol.toLowerCase();
    this.deltaBuy = 0;
    this.deltaSell = 0;
    this.orderbook = { bids: [], asks: [] };

    // è¿æ¥ aggTrade WebSocket
    this.wsTrade = new WebSocket(
      `wss://fstream.binance.com/ws/${this.symbol}@aggTrade`
    );

    this.wsTrade.on("message", (msg) => {
      const data = JSON.parse(msg);
      this.handleAggTrade(data);
    });

    // è¿æ¥ orderbook WebSocket
    this.wsDepth = new WebSocket(
      `wss://fstream.binance.com/ws/${this.symbol}@depth20@100ms`
    );

    this.wsDepth.on("message", (msg) => {
      const data = JSON.parse(msg);
      this.handleDepth(data);
    });
  }

  // å¤„ç†é€ç¬”æˆäº¤
  handleAggTrade(trade) {
    const qty = parseFloat(trade.q);
    if (trade.m === false) {
      // ä¹°æ–¹ä¸»åŠ¨ï¼ˆtaker æ˜¯ä¹°ï¼‰
      this.deltaBuy += qty;
    } else {
      // å–æ–¹ä¸»åŠ¨ï¼ˆtaker æ˜¯å–ï¼‰
      this.deltaSell += qty;
    }
  }

  // å¤„ç†è®¢å•ç°¿å¿«ç…§
  handleDepth(data) {
    this.orderbook = {
      bids: data.b.map(([price, qty]) => ({
        price: parseFloat(price),
        qty: parseFloat(qty),
      })),
      asks: data.a.map(([price, qty]) => ({
        price: parseFloat(price),
        qty: parseFloat(qty),
      })),
    };
  }

  // è·å–ä¹°å–ç›˜ä¸å¹³è¡¡ (ä¸»åŠ¨æˆäº¤)
  getDeltaImbalance() {
    if (this.deltaSell === 0) return Infinity;
    return this.deltaBuy / this.deltaSell;
  }

  // è·å–è®¢å•ç°¿æŒ‚å•ä¸å¹³è¡¡
  getOrderbookImbalance() {
    const bidSum = this.orderbook.bids.reduce((s, b) => s + b.qty, 0);
    const askSum = this.orderbook.asks.reduce((s, a) => s + a.qty, 0);
    if (askSum === 0) return Infinity;
    return bidSum / askSum;
  }

  // å®šæœŸé‡ç½®ï¼ˆé¿å…æ•°æ®æ— é™ç´¯ç§¯ï¼‰
  resetDelta() {
    this.deltaBuy = 0;
    this.deltaSell = 0;
  }
}

// ==== ä½¿ç”¨ç¤ºä¾‹ ====
const deltaFlow = new DeltaOrderflow("btcusdt");

// æ¯ 10 ç§’è¾“å‡ºä¸€æ¬¡æ•°æ®
setInterval(() => {
  console.log("ä¸»åŠ¨ä¹°å–ç›˜ç»Ÿè®¡:");
  console.log("deltaBuy:", deltaFlow.deltaBuy.toFixed(2));
  console.log("deltaSell:", deltaFlow.deltaSell.toFixed(2));
  console.log("æˆäº¤ä¸å¹³è¡¡ (Buy/Sell):", deltaFlow.getDeltaImbalance().toFixed(2));
  console.log("æŒ‚å•ä¸å¹³è¡¡ (Bid/Ask):", deltaFlow.getOrderbookImbalance().toFixed(2));
  console.log("----");

  // é‡ç½®ï¼Œé¿å…æ— é™ç´¯ç§¯
  deltaFlow.resetDelta();
}, 10000);
```

vwapé€»è¾‘å®ç°

```jsx
/**
 * è®¡ç®— VWAP
 * @param {Array} klines - Kçº¿æ•°æ®æ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ ä¸º [openTime, open, high, low, close, volume, ...]
 * @returns {number} VWAP å€¼
 */
function calculateVWAP(klines) {
  let pvSum = 0; // Price * Volume ç´¯ç§¯
  let vSum = 0;  // Volume ç´¯ç§¯

  for (const k of klines) {
    const high = parseFloat(k[2]);
    const low = parseFloat(k[3]);
    const close = parseFloat(k[4]);
    const volume = parseFloat(k[5]);

    // å…¸å‹ä»·æ ¼
    const typicalPrice = (high + low + close) / 3;

    pvSum += typicalPrice * volume;
    vSum += volume;
  }

  return vSum > 0 ? pvSum / vSum : null;
}

// ==== ç¤ºä¾‹è°ƒç”¨ ====
// å‡è®¾ä» Binance FAPI è·å– 1 å°æ—¶ 20 æ ¹Kçº¿
const sampleKlines = [
  // [openTime, open, high, low, close, volume, ...]
  [1690000000000, "30000", "30100", "29900", "30050", "120.5"],
  [1690003600000, "30050", "30200", "29950", "30100", "150.8"],
  [1690007200000, "30100", "30250", "30000", "30200", "200.3"],
];

console.log("VWAP:", calculateVWAP(sampleKlines));
```

**ğŸ”¹ 2.3 4H éœ‡è¡å¸‚ä¹Ÿéœ€è¦1Hå’Œ15åˆ†é’Ÿä¿¡å·ç¡®è®¤å…¥åœºæ‰§è¡Œç­–ç•¥**

- å‰æï¼štrend4h === "éœ‡è¡å¸‚"ï¼ˆä¸Šå±‚ä¼ å…¥ï¼‰
- 1H è¾¹ç•Œæœ‰æ•ˆæ€§ï¼šè¦æ±‚ 1H å¸ƒæ—å¸¦å¸¦å®½è¾ƒå°ï¼ˆè¡¨ç¤ºåŒºé—´ï¼‰ï¼Œå¹¶æ£€æµ‹æœ€è¿‘å‡ æ ¹ 1H æ˜¯å¦åœ¨ä¸Š/ä¸‹è½¨é™„è¿‘åå¤ï¼ˆè¯´æ˜è¾¹ç•Œæœ‰æ•ˆï¼‰ã€‚
- åŒºé—´äº¤æ˜“ï¼ˆé«˜èƒœç‡ï¼‰ï¼š
    - ä»·æ ¼æ¥è¿‘ä¸‹è½¨ä¸” 1H è¾¹ç•Œæœ‰æ•ˆ â†’ åœ¨ 15m å‡ºç°ç¼©é‡ä¸ç ´æˆ– 15m setup çªç ´ï¼ˆç¡®è®¤ï¼‰æ—¶åšå¤šã€‚
    - ä»·æ ¼æ¥è¿‘ä¸Šè½¨ â†’ å¯¹ç§°åšç©ºã€‚
- å‡çªç ´åæ‰‹ï¼ˆé«˜èµ”ç‡ï¼‰ï¼š
    - å‡ºç°çªç ´ä¸Š/ä¸‹è½¨çš„ 15mï¼ˆæˆ–1Hï¼‰K çº¿ï¼Œä½†éšåæ”¶å›å›åˆ°åŒºé—´å†…ï¼ˆä¸‹ä¸€æ ¹ 15m æˆ– 1H æ”¶å›ï¼‰ä¸”çªç ´é‡èƒ½ä¸è¶³ â†’ åæ‰‹å…¥åœºã€‚
- æ­¢æŸï¼šåœ¨è½¨å¤–ä¸€å®šæ¯”ä¾‹ï¼ˆæˆ–å‰ä¸€åå‘æå€¼ï¼‰ï¼Œæ­¢ç›ˆï¼šåˆ°åŒºé—´ä¸­è½¨æˆ–å¯¹ä¾§è½¨ï¼ˆå¯é…ç½®ï¼‰ã€‚

**éœ‡è¡å¸‚1håˆ¤æ–­ä»£ç é€»è¾‘**

```jsx
/**
 * range1h.js
 * åŠŸèƒ½ï¼šéœ‡è¡å¸‚ 1H åŒºé—´è¾¹ç•Œæœ‰æ•ˆæ€§ + VWAP/Delta/æˆäº¤é‡/OI/çªç ´ç¡®è®¤
 * è¾“å…¥ï¼š
 *   - candles1h: Array<{open, high, low, close, volume, time}>
 *   - oiData: Array<{time, oi}> æœ€è¿‘6å°æ—¶OIæ•°æ®
 *   - deltaData: Array<{time, delta}> æœ€è¿‘6å°æ—¶ä¹°å–ç›˜ä¸å¹³è¡¡æ•°æ®
 *   - opts: å¯é€‰å‚æ•° { bbPeriod, bbK, lowerTouchPct, upperTouchPct, volMultiplier, oiThreshold, deltaThreshold, breakoutPeriod }
 * è¾“å‡ºï¼š
 *   {
 *     lowerBoundaryValid,
 *     upperBoundaryValid,
 *     bb1h: {upper, middle, lower, bandwidth},
 *     vwap,
 *     delta,
 *     oiChange,
 *     lastBreakout
 *   }
 */

function sma(arr, len) {
  const slice = arr.slice(-len);
  return slice.reduce((a, b) => a + b, 0) / len;
}

function stddev(arr, len) {
  const m = sma(arr, len);
  return Math.sqrt(arr.slice(-len).reduce((acc, v) => acc + Math.pow(v - m, 2), 0) / len);
}

function bollingerBars(closes, period = 20, k = 2) {
  const m = sma(closes, period);
  const s = stddev(closes, period);
  return {
    middle: m,
    upper: m + k * s,
    lower: m - k * s,
    bandwidth: (m + k * s - (m - k * s)) / m
  };
}

function calcVWAP(candles) {
  let pv = 0, volSum = 0;
  for (const c of candles) {
    const tp = (c.high + c.low + c.close) / 3;
    pv += tp * c.volume;
    volSum += c.volume;
  }
  return volSum > 0 ? pv / volSum : null;
}

function avgVolume(candles, n) {
  if (!candles || candles.length < n) return null;
  return sma(candles.slice(-n).map(c => c.volume), n);
}

function range1h(candles1h, oiData = [], deltaData = [], opts = {}) {
  const p = {
    bbPeriod: opts.bbPeriod || 20,
    bbK: opts.bbK || 2,
    lowerTouchPct: opts.lowerTouchPct || 0.015,
    upperTouchPct: opts.upperTouchPct || 0.015,
    volMultiplier: opts.volMultiplier || 1.7,
    oiThreshold: opts.oiThreshold || 0.02,
    deltaThreshold: opts.deltaThreshold || 0.02,
    breakoutPeriod: opts.breakoutPeriod || 20
  };

  if (!candles1h || candles1h.length < p.bbPeriod + 5) {
    return { lowerBoundaryValid: false, upperBoundaryValid: false, bb1h: null };
  }

  const closes1h = candles1h.map(c => c.close);
  const bb1h = bollingerBars(closes1h, p.bbPeriod, p.bbK);

  // VWAP
  const vwap = calcVWAP(candles1h.slice(-p.bbPeriod));

  // è¾¹ç•Œè¿ç»­è§¦ç¢°åˆ¤æ–­
  const last1h = candles1h.slice(-6);
  let lowerTouches = 0, upperTouches = 0;
  for (const c of last1h) {
    if (c.close <= bb1h.lower * (1 + p.lowerTouchPct)) lowerTouches++;
    if (c.close >= bb1h.upper * (1 - p.upperTouchPct)) upperTouches++;
  }

  // æˆäº¤é‡å› å­
  const avgVol = avgVolume(candles1h, p.bbPeriod);
  const volFactor = last1h[last1h.length - 1].volume / avgVol; // æœ€æ–°1Hæˆäº¤é‡æ¯”

  // Delta å› å­
  const delta = deltaData.length > 0 ? deltaData[deltaData.length - 1].delta : 0;

  // OI å› å­
  let oiChange = 0;
  if (oiData.length >= 2) {
    const oiStart = oiData[0].oi;
    const oiEnd = oiData[oiData.length - 1].oi;
    oiChange = (oiEnd - oiStart) / oiStart; // æœ€è¿‘6Hå˜åŒ–ç‡
  }

  // æœ€è¿‘çªç ´ç¡®è®¤
  const recentHigh = Math.max(...closes1h.slice(-p.breakoutPeriod));
  const recentLow = Math.min(...closes1h.slice(-p.breakoutPeriod));
  const lastClose = closes1h[closes1h.length - 1];
  const lastBreakout = lastClose > recentHigh || lastClose < recentLow;

  // ç»¼åˆè¾¹ç•Œæœ‰æ•ˆæ€§
  const lowerBoundaryValid = lowerTouches >= 2 && volFactor <= p.volMultiplier && Math.abs(delta) <= p.deltaThreshold && Math.abs(oiChange) <= p.oiThreshold && !lastBreakout;
  const upperBoundaryValid = upperTouches >= 2 && volFactor <= p.volMultiplier && Math.abs(delta) <= p.deltaThreshold && Math.abs(oiChange) <= p.oiThreshold && !lastBreakout;

  return { lowerBoundaryValid, upperBoundaryValid, bb1h, vwap, delta, oiChange, lastBreakout };
}

// Node.js å¯¼å‡º
if (typeof module !== "undefined" && module.exports) {
  module.exports = { range1h, bollingerBars, sma, stddev, calcVWAP, avgVolume };
}
```

**15åˆ†é’Ÿæ‰§è¡Œåˆ¤æ–­**

```jsx
/**
 * range15m.js
 * åŠŸèƒ½ï¼šæ ¹æ® 1H è¾¹ç•Œåˆ¤æ–­ + 15m Kçº¿åšå…¥åœºæ‰§è¡Œ & å‡çªç ´åæ‰‹
 * è¾“å…¥ï¼š
 *   - range1hResult: { lowerBoundaryValid, upperBoundaryValid, bb1h }
 *   - candles15m: Array<{open, high, low, close, volume, time}>
 *   - candles1h: Array<{open, high, low, close, volume, time}> ï¼ˆç”¨äº avgVolumeï¼‰
 *   - opts: å¯é€‰å‚æ•°
 * è¾“å‡ºï¼š
 *   { signal, mode, entry, stopLoss, takeProfit, reason }
 */

function sma(arr, len) {
  const slice = arr.slice(-len);
  return slice.reduce((a, b) => a + b, 0) / len;
}

function avgVolume(candles, n) {
  if (!candles || candles.length < n) return null;
  return sma(candles.slice(-n).map(c => c.volume), n);
}

function range15m(range1hResult, candles15m, candles1h, opts = {}) {
  const p = {
    lowerTouchPct: opts.lowerTouchPct || 0.015,
    upperTouchPct: opts.upperTouchPct || 0.015,
    vol15mMultiplier: opts.vol15mMultiplier || 1.7,
    falseBreakVolThreshold: opts.falseBreakVolThreshold || 1.2,
    takeProfitMode: opts.takeProfitMode || "mid_or_opposite"
  };

  const { lowerBoundaryValid, upperBoundaryValid, bb1h } = range1hResult;
  if (!bb1h || !candles15m || candles15m.length < 2) {
    return { signal: "NONE", mode: "NONE", reason: "æ•°æ®ä¸è¶³æˆ–1Hè¾¹ç•Œæ— æ•ˆ" };
  }

  const last15 = candles15m[candles15m.length - 1];
  const prev15 = candles15m[candles15m.length - 2];

  const avgVol15m = avgVolume(candles15m, Math.min(20, candles15m.length)) || 0;
  const avgVol1h = avgVolume(candles1h, Math.min(20, candles1h.length)) || avgVol15m;

  const nearLower = last15.close <= bb1h.lower * (1 + p.lowerTouchPct);
  const nearUpper = last15.close >= bb1h.upper * (1 - p.upperTouchPct);

  // === åŒºé—´äº¤æ˜“ ===
  if (lowerBoundaryValid && nearLower) {
    const smallVolNotBreak = last15.volume < avgVol15m * 0.8 && last15.low >= bb1h.lower * 0.995;
    const setupBreak = last15.high > prev15.high && last15.close > prev15.high && last15.volume >= avgVol15m * 0.8;
    if (smallVolNotBreak || setupBreak) {
      const entry = Math.max(last15.close, prev15.high);
      const stopLoss = Math.min(bb1h.lower * 0.995, last15.low - last15.low * 0.005);
      const takeProfit = p.takeProfitMode === "mid_or_opposite" ? bb1h.middle : bb1h.upper;
      return { signal: "BUY", mode: "RANGE_LONG", entry, stopLoss, takeProfit, reason: "ä¸‹è½¨åŒºé—´äº¤æ˜“è§¦å‘" };
    }
  }

  if (upperBoundaryValid && nearUpper) {
    const smallVolNotBreak = last15.volume < avgVol15m * 0.8 && last15.high <= bb1h.upper * 1.005;
    const setupBreak = last15.low < prev15.low && last15.close < prev15.low && last15.volume >= avgVol15m * 0.8;
    if (smallVolNotBreak || setupBreak) {
      const entry = Math.min(last15.close, prev15.low);
      const stopLoss = Math.max(bb1h.upper * 1.005, last15.high + last15.high * 0.005);
      const takeProfit = p.takeProfitMode === "mid_or_opposite" ? bb1h.middle : bb1h.lower;
      return { signal: "SELL", mode: "RANGE_SHORT", entry, stopLoss, takeProfit, reason: "ä¸Šè½¨åŒºé—´äº¤æ˜“è§¦å‘" };
    }
  }

  // === å‡çªç ´åæ‰‹ ===
  const prevAboveUpper = prev15.close > bb1h.upper;
  const prevBelowLower = prev15.close < bb1h.lower;
  const lastBackInside = last15.close <= bb1h.upper && last15.close >= bb1h.lower;
  const prevVolRelative = prev15.volume / avgVol15m;

  if (prevAboveUpper && lastBackInside && prevVolRelative < p.falseBreakVolThreshold) {
    return {
      signal: "SELL",
      mode: "FALSE_BREAK_SHORT",
      entry: last15.close,
      stopLoss: Math.max(prev15.high * 1.01, bb1h.upper * 1.02),
      takeProfit: bb1h.lower,
      reason: "å‘ä¸Šå‡çªç ´å¤±è´¥åæ‰‹"
    };
  }

  if (prevBelowLower && lastBackInside && prevVolRelative < p.falseBreakVolThreshold) {
    return {
      signal: "BUY",
      mode: "FALSE_BREAK_LONG",
      entry: last15.close,
      stopLoss: Math.min(prev15.low * 0.99, bb1h.lower * 0.98),
      takeProfit: bb1h.upper,
      reason: "å‘ä¸‹å‡çªç ´å¤±è´¥åæ‰‹"
    };
  }

  return { signal: "NONE", mode: "NONE", reason: "æœªå‘½ä¸­åŒºé—´æˆ–å‡çªç ´æ¡ä»¶" };
}

// Node.js å¯¼å‡º
if (typeof module !== "undefined" && module.exports) {
  module.exports = { range15m, avgVolume };
}
```

ä½¿ç”¨ç¤ºä¾‹ï¼š

```jsx
const { range1h } = require('./range1h');
const { range15m } = require('./range15m');

// 1. è®¡ç®—1HåŒºé—´è¾¹ç•Œ
const range1hResult = range1h(candles1h);

// 2. 15åˆ†é’Ÿå…¥åœºæ‰§è¡Œ
const res = range15m(range1hResult, candles15m, candles1h);

console.log(res);
```

### **ğŸ“Œ JS å®ç°ï¼šéœ‡è¡å¸‚æ­¢æŸé€»è¾‘**

```jsx
/**
 * éœ‡è¡å¸‚æ­¢æŸé€»è¾‘
 * @param {Object} params
 * @param {string} params.side - "long" æˆ– "short"
 * @param {number} params.entryPrice - å…¥åœºä»·æ ¼
 * @param {number} params.atr - ATR(14) å€¼
 * @param {number} params.setupHigh - setup candle é«˜ç‚¹
 * @param {number} params.setupLow - setup candle ä½ç‚¹
 * @param {number} params.rangeHigh - 1H åŒºé—´é«˜ç‚¹
 * @param {number} params.rangeLow - 1H åŒºé—´ä½ç‚¹
 * @param {number} params.currentPrice - æœ€æ–°ä»·æ ¼
 * @param {number} params.hoursHeld - æŒä»“å°æ—¶æ•°
 * @param {Object} params.factors - å› å­çŠ¶æ€ { vwap: boolean, delta: boolean, oi: boolean, volume: boolean }
 * @returns {Object} { stopLossHit: boolean, reason: string }
 */
function calculateStopLoss({
  side,
  entryPrice,
  atr,
  setupHigh,
  setupLow,
  rangeHigh,
  rangeLow,
  currentPrice,
  hoursHeld,
  factors
}) {
  let stopLossPrice;
  let reason = "";

  // 1. åˆå§‹æ­¢æŸ (ATR + setup candle)
  if (side === "long") {
    stopLossPrice = Math.min(setupLow, entryPrice - 1.2 * atr);
  } else {
    stopLossPrice = Math.max(setupHigh, entryPrice + 1.2 * atr);
  }

  if ((side === "long" && currentPrice < stopLossPrice) ||
      (side === "short" && currentPrice > stopLossPrice)) {
    return { stopLossHit: true, reason: "ATR/Setup æ­¢æŸè§¦å‘" };
  }

  // 2. åŒºé—´è¾¹ç•Œå¤±æ•ˆæ­¢æŸ
  if (side === "long" && currentPrice < (rangeLow - atr)) {
    return { stopLossHit: true, reason: "åŒºé—´ä¸‹è¾¹ç•Œå¤±æ•ˆ" };
  }
  if (side === "short" && currentPrice > (rangeHigh + atr)) {
    return { stopLossHit: true, reason: "åŒºé—´ä¸Šè¾¹ç•Œå¤±æ•ˆ" };
  }

  // 3. æ—¶é—´æ­¢æŸ (è¶…è¿‡ 6 å°æ—¶æ— è¿›å±•)
  if (hoursHeld >= 6) {
    return { stopLossHit: true, reason: "æ—¶é—´æ­¢æŸï¼ˆ6å°æ—¶æœªè¾¾ç›®æ ‡ï¼‰" };
  }

  // 4. å¤šå› å­æ­¢æŸ (VWAP/Delta/OI/Volume æ–¹å‘é”™è¯¯)
  if (factors) {
    const badFactors = Object.entries(factors)
      .filter(([key, val]) => val === false)
      .map(([key]) => key);

    if (badFactors.length >= 2) {
      return { stopLossHit: true, reason: `å› å­æ­¢æŸ: ${badFactors.join(", ")}` };
    }
  }

  return { stopLossHit: false, reason: "æŒä»“ä¸­" };
}
```

### **ğŸ“Œ ç”¨æ³•ç¤ºä¾‹**

```jsx
const result = calculateStopLoss({
  side: "long",
  entryPrice: 30000,
  atr: 150,
  setupHigh: 30200,
  setupLow: 29800,
  rangeHigh: 30500,
  rangeLow: 29500,
  currentPrice: 29400,
  hoursHeld: 2,
  factors: { vwap: true, delta: false, oi: false, volume: true }
});

console.log(result);
// { stopLossHit: true, reason: "åŒºé—´ä¸‹è¾¹ç•Œå¤±æ•ˆ" }
```

### éœ‡è¡å¸‚æ­¢ç›ˆé€»è¾‘

```jsx
/**
 * éœ‡è¡å¸‚æ­¢ç›ˆé€»è¾‘
 * @param {Object} params
 * @param {string} params.side - "long" æˆ– "short"
 * @param {number} params.entryPrice - å…¥åœºä»·æ ¼
 * @param {number} params.targetRR - é£é™©å›æŠ¥æ¯”ç›®æ ‡ (ä¾‹å¦‚ 2 è¡¨ç¤º 1:2)
 * @param {number} params.atr - ATR(14) å€¼
 * @param {number} params.rangeHigh - 1H åŒºé—´é«˜ç‚¹
 * @param {number} params.rangeLow - 1H åŒºé—´ä½ç‚¹
 * @param {number} params.currentPrice - æœ€æ–°ä»·æ ¼
 * @param {number} params.stopLossPrice - å·²è®¾å®šæ­¢æŸä»·
 * @param {number} params.hoursHeld - æŒä»“æ—¶é—´
 * @returns {Object} { takeProfitHit: boolean, reason: string, takeProfitPrice: number }
 */
function calculateTakeProfit({
  side,
  entryPrice,
  targetRR,
  atr,
  rangeHigh,
  rangeLow,
  currentPrice,
  stopLossPrice,
  hoursHeld
}) {
  let takeProfitPrice;
  let reason = "";

  // 1. è®¡ç®—åŸºç¡€æ­¢ç›ˆä»·æ ¼ (é£é™©å›æŠ¥æ¯”)
  const riskDistance = Math.abs(entryPrice - stopLossPrice);
  if (side === "long") {
    takeProfitPrice = entryPrice + targetRR * riskDistance;
  } else {
    takeProfitPrice = entryPrice - targetRR * riskDistance;
  }

  // 2. åŒºé—´è¾¹ç•Œæ­¢ç›ˆ (ä¼˜å…ˆæ€§é«˜äºRR)
  if (side === "long") {
    takeProfitPrice = Math.min(takeProfitPrice, rangeHigh - atr * 0.5);
  } else {
    takeProfitPrice = Math.max(takeProfitPrice, rangeLow + atr * 0.5);
  }

  // 3. æ—¶é—´æ­¢ç›ˆ (è¶…è¿‡12å°æ—¶æœªè§¦å‘æ­¢ç›ˆï¼Œå¼ºå¹³ä¸€åŠ)
  if (hoursHeld >= 12) {
    return {
      takeProfitHit: true,
      reason: "æ—¶é—´æ­¢ç›ˆï¼ˆ12å°æ—¶å‡ºåœºï¼‰",
      takeProfitPrice: currentPrice
    };
  }

  // 4. æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æ­¢ç›ˆä»·æ ¼
  if ((side === "long" && currentPrice >= takeProfitPrice) ||
      (side === "short" && currentPrice <= takeProfitPrice)) {
    return { takeProfitHit: true, reason: "ç›®æ ‡æ­¢ç›ˆè¾¾æˆ", takeProfitPrice };
  }

  return { takeProfitHit: false, reason: "æŒä»“ä¸­", takeProfitPrice };
}
```


# **3. å…³é”®æŒ‡æ ‡è®¡ç®—é€»è¾‘**

**MA (ç§»åŠ¨å‡çº¿)**

MA_n = \frac{\sum_{i=1}^n Close_i}{n}

**EMA (æŒ‡æ•°ç§»åŠ¨å‡çº¿)**

EMA_t = Price_t \times \frac{2}{n+1} + EMA_{t-1} \times \Big(1 - \frac{2}{n+1}\Big)

**ADX(14)**

1. è®¡ç®— +DI, -DIï¼š
+DI = \frac{Smoothed(+DM)}{ATR}, \quad -DI = \frac{Smoothed(-DM)}{ATR}
2. è®¡ç®— DXï¼š
DX = \frac{|+DI - -DI|}{|+DI + -DI|} \times 100
3. ADX = DX çš„ 14æœŸå‡å€¼ã€‚
ğŸ‘‰ ADX > 20 = æœ‰æ•ˆè¶‹åŠ¿ã€‚

**å¸ƒæ—å¸¦å¸¦å®½ (BB Width)**

BB\ Width = \frac{Upper - Lower}{Middle}

å…¶ä¸­ï¼š

- Middle = MA20
- Upper = MA20 + 2 Ã— StdDev(20)
- Lower = MA20 - 2 Ã— StdDev(20)
ğŸ‘‰ å®½åº¦å¢åŠ  = è¶‹åŠ¿å¯åŠ¨ã€‚

**VWAP (æˆäº¤é‡åŠ æƒå‡ä»·)**

VWAP = \frac{\sum (Price \times Volume)}{\sum Volume}

**OI (æœªå¹³ä»“åˆçº¦é‡å˜åŒ–ç‡)**

\[

OI\ Change\% = \frac{OI_{now} - OI_{6h\ago}}{OI{6h\_ago}} \times 100\%

\]

**ATR (æ³¢åŠ¨ç‡æ­¢æŸ)**

TR = \max(High-Low, |High-Close_{prev}|, |Low-Close_{prev}|)

ATR = EMA_{14}(TR)

# **4. æ•°æ®åˆ·æ–°é¢‘ç‡å»ºè®®**

| **æ—¶é—´æ¡†æ¶** | **åˆ·æ–°é¢‘ç‡** | **ç†ç”±** |
| --- | --- | --- |
| 4H è¶‹åŠ¿ | æ¯ 1 å°æ—¶ | è¶³å¤Ÿç¨³å®šï¼Œå‡å°‘APIå‹åŠ› |
| 1H æ‰“åˆ† | æ¯ 5 åˆ†é’Ÿ | æå‰æ•æ‰çªç ´å’ŒVWAPåç§» |
| 15m å…¥åœº | æ¯ 1~3 åˆ†é’Ÿ | ç²¾ç¡®æ•æ‰setupçªç ´ |
| Delta/ç›˜å£ | å®æ—¶ï¼ˆWebSocketï¼‰ | å¦åˆ™å¤±å»æ„ä¹‰ |

# **âœ…** æµç¨‹å›¾

```mermaid
flowchart TD
    A(å¼€å§‹) --> B(è·å–Kçº¿æ•°æ®: 4H, 1H, 15m)
    B --> C(åˆ¤æ–­4Hè¶‹åŠ¿ trend4h)

    %% è¶‹åŠ¿å¸‚åˆ†æ”¯
    C -->|è¶‹åŠ¿å¸‚| D(è¶‹åŠ¿å¸‚ 1H æ‰“åˆ† score1hResult)
    D --> E{score1hResult æœ‰æ•ˆå—?}
    E -->|å¦| F(ä¸äº¤æ˜“ signal=NONE)
    E -->|æ˜¯| G(è¶‹åŠ¿å¸‚ 15m å…¥åœºæ‰§è¡Œ)
    G --> G1{è§¦å‘å…¥åœºæ¡ä»¶?}
    G1 -->|å¦| F
    G1 -->|æ˜¯| G2(è®¡ç®—å…¥åœºä»·ï¼Œå‚è€ƒ setup candle é«˜ç‚¹æˆ–ä½ç‚¹)
    G2 --> G3(è®¡ç®—æ­¢æŸï¼Œsetup candle å¦ä¸€ç«¯ æˆ– ATR14 å–æ›´è¿œ)
    G3 --> G4(è®¡ç®—æ­¢ç›ˆï¼Œentry + 2R æˆ–ç›®æ ‡ä»·)
    G4 --> U(è¾“å‡ºä¿¡å· & æ‰§è¡Œä¸‹å•)

    %% éœ‡è¡å¸‚åˆ†æ”¯
    C -->|éœ‡è¡å¸‚| K(éœ‡è¡å¸‚ 1H è¾¹ç•Œåˆ¤æ–­ range1h)
    K --> K1(è®¡ç®—å¸ƒæ—å¸¦ BB1H)
    K --> K2(è®¡ç®—VWAP)
    K --> K3(è®¡ç®—Delta)
    K --> K4(è®¡ç®—æˆäº¤é‡å› å­)
    K --> K5(è®¡ç®—OIå˜åŒ–)
    K --> K6(æ£€æŸ¥æœ€è¿‘çªç ´ lastBreakout)

    K1 --> L{ä¸‹è½¨è¾¹ç•Œæœ‰æ•ˆ? è¿ç»­è§¦ç¢° + VWAP + Delta + Vol + OI + æ— çªç ´}
    L -->|æ˜¯| M(15m åŒºé—´å¤šå¤´æ‰§è¡Œ range15m)
    L -->|å¦| N(ç»§ç»­ç­‰å¾…/ä¸äº¤æ˜“)

    K1 --> O{ä¸Šè½¨è¾¹ç•Œæœ‰æ•ˆ? è¿ç»­è§¦ç¢° + VWAP + Delta + Vol + OI + æ— çªç ´}
    O -->|æ˜¯| P(15m åŒºé—´ç©ºå¤´æ‰§è¡Œ range15m)
    O -->|å¦| N

    %% 15m æ‰§è¡Œå¤šå¤´
    M --> Q1{ç¼©é‡ä¸ç ´ æˆ– setup candle é«˜ç‚¹çªç ´?}
    Q1 -->|å¦| N
    Q1 -->|æ˜¯| R1(è®¡ç®—å…¥åœºä»·ï¼Œsetup candle é«˜ç‚¹)
    R1 --> R2(æ­¢æŸï¼Œsetup candle ä½ç‚¹ æˆ– ATR14 å–æ›´è¿œ)
    R2 --> R3(æ­¢ç›ˆï¼Œentry + 2R æˆ–åŒºé—´ä¸­è½¨/ä¸Šè½¨)
    R3 --> U

    %% 15m æ‰§è¡Œç©ºå¤´
    P --> S1{ç¼©é‡ä¸ç ´ æˆ– setup candle ä½ç‚¹çªç ´?}
    S1 -->|å¦| N
    S1 -->|æ˜¯| T1(è®¡ç®—å…¥åœºä»·ï¼Œsetup candle ä½ç‚¹)
    T1 --> T2(æ­¢æŸï¼Œsetup candle é«˜ç‚¹ æˆ– ATR14 å–æ›´è¿œ)
    T2 --> T3(æ­¢ç›ˆï¼Œentry - 2R æˆ–åŒºé—´ä¸­è½¨/ä¸‹è½¨)
    T3 --> U

    U --> V(ç»“æŸ/è¿”å›äº¤æ˜“ä¿¡å·)
```

# äº¤æ˜“å¯¹é€‰æ‹©åŠäº¤æ˜“é¢‘ç‡å»ºè®®

| **ç±»åˆ«** | **å…¸å‹ä»£å¸** | **æŸ¥è¯¢ç½‘ç«™** | **æ¨è API / æ¥å£** | **æŸ¥è¯¢ JS ç‰‡æ®µ** | **æŸ¥è¯¢é¢‘ç‡** | **å»ºè®®äº¤æ˜“é¢‘ç‡** | **å»ºè®®æŒä»“æ—¶é•¿** |
| --- | --- | --- | --- | --- | --- | --- | --- |
| ä¸»æµå¸ï¼ˆé«˜æµåŠ¨æ€§ï¼‰ | BTC, ETH | [CoinMarketCap](https://coinmarketcap.com/), [CoinGecko](https://www.coingecko.com/) | CoinGecko /coins/markets?vs_currency=usd&order=market_cap_desc&per_page=10&page=1 | fetchTopN(10) | æ¯æœˆ 1 æ¬¡ï¼ˆ00:00 UTC æ›´æ–°ï¼‰ | è¶‹åŠ¿å¸‚ï¼šæ¯å‘¨ 1â€“3 ç¬”ï¼›éœ‡è¡å¸‚ï¼šæ¯å¤© 0â€“2 ç¬” | è¶‹åŠ¿å¸‚ï¼šå¯æŒä»“ 1â€“7 å¤©ï¼ˆè·Ÿéšè¶‹åŠ¿ï¼‰ï¼›éœ‡è¡å¸‚ï¼š1â€“12 å°æ—¶ï¼ˆé¿å…è´¹ç‡åƒæ‰åˆ©æ¶¦ï¼‰ |
| é«˜å¸‚å€¼å¼ºè¶‹åŠ¿å¸ | BNB, SOL, XRP, ADA, DOGE, DOT, LTC, TRX, BCH, ETC | åŒä¸Š | åŒä¸Š APIï¼Œè¿‡æ»¤ BTC/ETH/ç¨³å®šå¸ï¼Œå– rank 3â€“20 | fetchTopN(30) + è¿‡æ»¤ | æ¯å‘¨ 1 æ¬¡ | è¶‹åŠ¿å¸‚ï¼šæ¯å‘¨ 1â€“2 ç¬”ï¼›éœ‡è¡å¸‚ï¼šæ¯å¤© 1â€“3 ç¬” | è¶‹åŠ¿å¸‚ï¼š0.5â€“3 å¤©ï¼›éœ‡è¡å¸‚ï¼šæ•°å°æ—¶å†…ï¼ˆé¿å…é«˜è´¹ç‡ç£¨æŸï¼‰ |
| çƒ­ç‚¹å¸ï¼ˆTrending / çƒ­æœï¼‰ | å®æ—¶å˜åŒ–ï¼ˆå¦‚ Worldcoin, Avantis ç­‰ï¼‰ | [CoinGecko Trending](https://www.coingecko.com/en/trending) | CoinGecko /search/trending | fetchTrending() | æ¯å°æ—¶ 1 æ¬¡ | è¶‹åŠ¿å¸‚ï¼šæ¯å‘¨ 1â€“2 ç¬”ï¼›éœ‡è¡å¸‚ï¼šæ¯å¤© 2â€“4 ç¬”ï¼ˆéœ€ä¸¥æ ¼é£æ§ï¼‰ | è¶‹åŠ¿å¸‚ï¼š6â€“24 å°æ—¶ï¼ˆé«˜æ³¢åŠ¨å¿«é€Ÿæ­¢ç›ˆæ­¢æŸï¼‰ï¼›éœ‡è¡å¸‚ï¼š1â€“3 å°æ—¶ä»¥å†… |
| å°å¸ï¼ˆä½æµåŠ¨æ€§ï¼‰ | å¸‚å€¼ < $50M çš„é•¿å°¾å¸ | CoinGecko å¸‚å€¼æ’åº | CoinGecko /coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&page=1 + æœ¬åœ°è¿‡æ»¤ | fetchSmallCaps(1e6, 5e7) | æ¯å¤© 1 æ¬¡ | ä¸åšè¶‹åŠ¿ï¼›éœ‡è¡å¸‚ï¼šæ¯å¤© 1â€“2 ç¬”ï¼ˆå°ä»“ä½ â‰¤1% é£é™©ï¼‰ | ä»…éœ‡è¡å¸‚ï¼š0.5â€“2 å°æ—¶ï¼ˆé¿å…çˆ†ä»“é£é™©ï¼‰ï¼›ä¸å»ºè®®é•¿æ—¶é—´æŒæœ‰ |
| Binance åˆçº¦å¯ç”¨æ€§æ£€æŸ¥ | Binance Futures æ‰€æœ‰åˆçº¦å¯¹ | [Binance Futures Products](https://www.binance.com/en/futures) | Binance /fapi/v1/exchangeInfo | checkBinanceContracts() | æ¯å¤© 1 æ¬¡ | â€”ï¼ˆä»…æ£€æŸ¥æ˜¯å¦å¯äº¤æ˜“ï¼Œä¸ç›´æ¥å†³å®šé¢‘ç‡ï¼‰ | ä»…ç¡®è®¤å¯äº¤æ˜“æ€§ï¼Œä¸å†³å®šæŒä»“ |

# æœ€å¤§æ æ†å’Œæœ€å°ä¿è¯é‡‘è®¡ç®—æ–¹å¼
é‡‡ç”¨é€ä»“æ¨¡å¼ï¼Œæ­¢æŸè·ç¦»ï¼Œæœ€å¤§æ æ†æ•°å’Œæœ€å°ä¿è¯é‡‘æ•°è®¡ç®—æ–¹å¼ï¼š
- æ­¢æŸè·ç¦»X%ï¼š
  - å¤šå¤´ï¼š(entrySignal - stopLoss) / entrySignal
  - ç©ºå¤´ï¼š(stopLoss - entrySignal) / entrySignal
- æœ€å¤§æŸå¤±é‡‘é¢(U)ï¼šç”¨æˆ·é€‰æ‹©çš„å•æ¬¡äº¤æ˜“æœ€å¤§æŸå¤±é‡‘é¢
    - æœ€å¤§æ æ†æ•°Yï¼š1/(X%+0.5%) æ•°å€¼å‘ä¸‹å–æ•´ã€‚
    - ä¿è¯é‡‘Zï¼šM/(Y*X%) æ•°å€¼å‘ä¸Šå–æ•´ã€‚